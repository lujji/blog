<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Bare metal programming: STM8 | lujji</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="This article will cover developing for STM8 series of microcontrolles completely from scratch, without using any vendor-supplied libraries.">
<meta property="og:type" content="article">
<meta property="og:title" content="Bare metal programming: STM8">
<meta property="og:url" content="http://lujji.github.io/blog/bare-metal-programming-stm8/index.html">
<meta property="og:site_name" content="lujji">
<meta property="og:description" content="This article will cover developing for STM8 series of microcontrolles completely from scratch, without using any vendor-supplied libraries.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/breakout.jpg">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/portd_registers.png">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/blink.jpg">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/uart.png">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/spi_master.png">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/spi_master_fixed.png">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/nokia_lcd.jpg">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/i2c.svg">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/i2c_screenshot.png">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/i2c_fixed_screenshot.png">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/timer_prescaler.svg">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/timer_f_io.svg">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/demo.jpg">
<meta property="article:published_time" content="2017-03-03T22:00:00.000Z">
<meta property="article:modified_time" content="2023-02-14T11:37:17.395Z">
<meta property="article:author" content="lujji">
<meta property="article:tag" content="bare-metal">
<meta property="article:tag" content="sdcc">
<meta property="article:tag" content="stm8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8/breakout.jpg">
  
    <link rel="alternate" href="atom.xml" title="lujji" type="application/atom+xml">
  
  
    <link rel="icon" href="/blog/css/images/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">lujji</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">embedded stuff</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
      <a id="nav-github-link" class="nav-icon" target="_blank" rel="noopener" href="https://github.com/lujji" title="GitHub"></a>
        
          <a id="nav-rss-link" class="nav-icon" href="atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//duckduckgo.com" method="get" accept-charset="UTF-8" onsubmit="var qstr = document.getElementById('searchBox'); qstr.value += ' site:http://lujji.github.io/blog'" class="search-form"><input id="searchBox" type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-bare-metal-programming-stm8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/bare-metal-programming-stm8/" class="article-date">
  <time datetime="2017-03-03T22:00:00.000Z" itemprop="datePublished">2017-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Bare metal programming: STM8
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This article will cover developing for STM8 series of microcontrolles completely from scratch, without using any vendor-supplied libraries.</p>
<span id="more"></span>
<hr>
<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>STM8 is a cheap 8-bit microcontroller aimed towards low-cost mass-market devices. Initially I came across this part while searching for a simple microcontroller as a replacement for AVRs. Despite having various ARM Cortex-M0 devices available on the market for quite attractive prices, AVRs have one advantage - simplicity. Utilizing an ARM Cortex core to switch some lights on and off seems like an overkill. Some applications just don’t require that amount of flexibility and performance.</p>
<p>The main goal of this article is to demonstrate that ‘bare metal’ programming is not a difficult task and to give you an overview of STM8’s architecture and peripherals. Even though writing peripheral drivers from scratch might seem like reinventing the wheel, in many cases it is easier and faster to implement the functionality that <em>you</em> need for a specific task, instead of relying on vendor-supplied libraries that try to do everything at once (and fail).</p>
<h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents:"></a>Contents:</h2><ul>
<li><a href="#The-Hardware">The Hardware</a></li>
<li><a href="#Setting-up-toolchain">Setting up toolchain</a></li>
<li><a href="#It%E2%80%99s-all-just-memory">It’s all just memory..</a></li>
<li><a href="#First-program">First program</a></li>
<li><a href="#Peripheral-drivers">Peripheral drivers</a><br>– <a href="#UART">UART</a><br>– <a href="#SPI">SPI</a><br>– <a href="#I2C">I2C</a><br>– <a href="#ADC">ADC</a><br>– <a href="#Timers-and-interrupts">Timers and interrupts</a></li>
<li><a href="#Putting-it-all-together">Putting it all together</a></li>
<li><a href="#Conclusion">Conclusion</a></li>
</ul>
<h2 id="The-Hardware"><a href="#The-Hardware" class="headerlink" title="The Hardware"></a>The Hardware</h2><p>There is a number of ways to start working with STM8. The easiest one is to get a Discovery board, although I wouldn’t recommend it, since STM8 Discovery boards aren’t that good and the on-board ST-Link v1 firmware just sucks.</p>
<p>Instead, I’ll opt for the minimalist approach. All you need is an ST-Link v2, STM8S003F3 and a breakout board. STM8S003F3 comes in a handy TSSOP20 package which is very easy to solder.</p>
<img src="/blog/bare-metal-programming-stm8/breakout.jpg" alt="Poor man's devboard" title="Poor man's devboard">

<p><strong><em>Note: a 1uF capacitor on VCAP pin is required for the processor to operate.</em></strong></p>
<h2 id="Setting-up-toolchain"><a href="#Setting-up-toolchain" class="headerlink" title="Setting up toolchain"></a>Setting up toolchain</h2><p>The biggest downside is that STM8 processors are not supported by GCC. There are 3 commercial compilers available for these processors: Raisonance, Cosmic and IAR. Some of these compilers have free versions with code size limit, but none of them are available for linux. Luckily, SDCC supports STM8 and that’s what we’re going to use. SDCC is being actively developed, so I suggest trying the latest snapshot build instead of the stable version. To program the microcontroller we’ll be using stm8flash. The first step is to download all the necessary tools:</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/sdcc/files/snapshot_builds/">sdcc</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/vdudouyt/stm8flash">stm8flash</a></li>
</ol>
<p>Extract SDCC under ~&#x2F;local&#x2F;sdcc. Now extract stm8flash, build it with <code>make</code> and copy stm8flash binary to ~&#x2F;local&#x2F;sdcc&#x2F;bin. I prefer to keep flasher with compiler for convenience. Next, add the following line to your .bashrc file (replacing <em>username</em> with your user name):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/username/local/sdcc</span><br></pre></td></tr></table></figure>

<p>If everything was done properly, you should be able to run <code>sdcc --version</code>. The last remaining thing is to write udev rule for ST-Link programmer. Create a file <code>/etc/udev/rules.d/99-stlink.rules</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ST-Link v1/v2</span><br><span class="line">ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;3744&quot;, MODE=&quot;0666&quot;</span><br><span class="line">ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;3748&quot;, MODE=&quot;0666&quot;</span><br></pre></td></tr></table></figure>

<p>Finally, run <code>udevadm control --reload-rules &amp;&amp; udevadm trigger</code> as root. Now we’re all set and ready to start.</p>
<h2 id="It’s-all-just-memory"><a href="#It’s-all-just-memory" class="headerlink" title="It’s all just memory.."></a>It’s all just memory..</h2><p>Before we begin, let’s take a simple example of accessing port register on ATmega and see what’s going on under the hood:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Port access operation */</span></span><br><span class="line">PORTB = (<span class="number">1</span> &lt;&lt; PB2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expanding macros (same as above) */</span></span><br><span class="line">(* (<span class="keyword">volatile</span> <span class="keyword">uint8_t</span> *) ((<span class="number">0x05</span>) + <span class="number">0x20</span>)) = (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same as above */</span></span><br><span class="line">* (<span class="keyword">volatile</span> <span class="keyword">uint8_t</span> *) <span class="number">0x25</span> = <span class="number">0x04</span>;</span><br></pre></td></tr></table></figure>

<p>Typecasting integer to a pointer is a valid operation in C. If you don’t quite understand what is going on with pointer arithmetics then here’s another example for you:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> a = <span class="number">0xDE</span>;  <span class="comment">// a contains 0xDE</span></span><br><span class="line"><span class="keyword">uint8_t</span> *ptr = &amp;a; <span class="comment">// ptr points to a</span></span><br><span class="line">*ptr = <span class="number">0xAD</span>; <span class="comment">// a contains 0xAD</span></span><br></pre></td></tr></table></figure>

<p>The only difference is that in the first example we know exactly which address in memory we are going to use. It’s important that you understand what’s going on here, since we’re going to use this mechanism for accessing hardware registers later on.</p>
<h2 id="First-program"><a href="#First-program" class="headerlink" title="First program"></a>First program</h2><p>These are the two most important documents: <a href="st.com/resource/en/datasheet/stm8s003k3.pdf">datasheet</a> and <a href="www.st.com/resource/en/reference_manual/CD00190271.pdf">reference manual</a>. We’ll use the datasheet for the pinout and register map. Everything else is present in the reference manual: peripheral operation, register description, etc. Let’s begin by opening the GPIO section of the reference manual and taking a closer look at PORTD registers.</p>
<img src="/blog/bare-metal-programming-stm8/portd_registers.png" alt="PORTD registers" title="PORTD registers">

<p>These registers are pretty much self-explanatory but just in case, here’s a brief overview: <code>DDR</code> is the direction register, which configures a pin as either an input or an output. After we configured <code>DDR</code> we can use <code>ODR</code> for writing or <code>IDR</code> for reading pin state. Control registers <code>CR1</code> and <code>CR2</code> are used for configuring internal pull-ups, output speed and selecting between push-pull or pseudo open-drain.</p>
<p>First, let’s define a macro that we’ll use later on for register definitions. Base address for all the hardware registers is 0x5000 so we can hardcode that into our macro.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SFR_(mem_addr)      (*(volatile uint8_t *)(0x5000 + (mem_addr)))</span></span><br></pre></td></tr></table></figure>

<p>Now let’s try blinking an LED. For this task we need to define <code>ODR</code>, <code>DDR</code> and <code>CR1</code> registers for PORTD. We also need a delay function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_CPU 2000000UL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SFR_(mem_addr)     (*(volatile uint8_t *)(0x5000 + (mem_addr)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PORT D */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_ODR      _SFR_(0x0F)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_DDR      _SFR_(0x11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_CR1      _SFR_(0x12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_PIN     4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(<span class="keyword">uint16_t</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((F_CPU / <span class="number">18000U</span>L) * ms); i++)</span><br><span class="line">        <span class="keyword">__asm__</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PD_DDR |= (<span class="number">1</span> &lt;&lt; LED_PIN); <span class="comment">// configure PD4 as output</span></span><br><span class="line">    PD_CR1 |= (<span class="number">1</span> &lt;&lt; LED_PIN); <span class="comment">// push-pull mode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* toggle pin every 250ms */</span></span><br><span class="line">        PD_ODR ^= (<span class="number">1</span> &lt;&lt; LED_PIN);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Save this in main.c and compile by running the following command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdcc -lstm8 -mstm8 --out-fmt-ihx --std-sdcc11 main.c</span><br></pre></td></tr></table></figure>

<p>Now attach st-link and flash the microcontroller.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stm8flash -c stlinkv2 -p stm8s003f3 -w main.ihx</span><br></pre></td></tr></table></figure>
<br/>
<img src="/blog/bare-metal-programming-stm8/blink.jpg" alt="It's alive!" title="It's alive!">

<p>Congratulations! We’ve just written our first program from scratch.</p>
<p><em>Note: some of the STM8 pins are labeled with <code>(T)</code> in the datasheet. These pins are ‘true’ open-drain and can only pull to ground. You should be extra careful when working with open-drain pins, since there are no protection diodes. I managed to accidentally blow PB5 by using it as a normal GPIO, which took me hours to figure out when my I2C code wasn’t working. One way of checking whether the pin is dead or not is by setting the multimeter in diode mode and measuring the voltage drop between the pin and ground - it should be roughly 0.7V in one direction.</em></p>
<h2 id="Peripheral-drivers"><a href="#Peripheral-drivers" class="headerlink" title="Peripheral drivers"></a>Peripheral drivers</h2><h3 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h3><p>After toggling some IO pins the first thing that you should get up and running on a new platform is UART. It makes debugging much easier. As always, we begin with register definitions.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UART */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_SR     _SFR_(0x230)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_TXE    7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_TC     6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_RXNE   5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_DR     _SFR_(0x231)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BRR1   _SFR_(0x232)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BRR2   _SFR_(0x233)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_CR1    _SFR_(0x234)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_CR2    _SFR_(0x235)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_TEN    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_REN    2</span></span><br></pre></td></tr></table></figure>

<p>Usually, in order to initialize UART one has to calculate baud and write the resulting value into the corresponding HIGH and LOW registers. Let’s see how this is done in STM8.</p>
<img src="/blog/bare-metal-programming-stm8/uart.png" alt="What were they thinking?!" title="What were they thinking?!">
<p>So.. you get a 16-bit value and you write the first nibble [15:12] into BRR2[7:4], then you write bits [11:4] into BRR1 and finally you write the remaining bits [3:0] into BRR2[3:0]. Seriously, what were they thinking? Why couldn’t ST just implement BRR_HIGH and BRR_LOW for the sake of it? All this bit-fiddling just seems unnecessarily complicated.</p>
<p>Anyway, let’s move on to initialization. We’ll stick with the default 8 data bits, 1 stop bit and no parity. Since our master clock is 2MHz, for baud &#x3D; 9600 we have UART_DIV &#x3D; 2000000&#x2F;9600 &#x3D; 208 (0xD0). According to the bizarre diagram above, we end up with BRR1 &#x3D; 0x0D and BRR2 &#x3D; 0x00. One thing to keep in mind is that BRR2 register must be written before BRR1. Finally, we turn on receiver and transmitter in Control Register 2. Read and write functions are pretty straight-forward: you read&#x2F;write the Data Register and wait until the appropriate bit in Status Register is set.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PD5 -&gt; TX</span></span><br><span class="line"><span class="comment"> * PD6 -&gt; RX</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UART_BRR2 = <span class="number">0x00</span>;</span><br><span class="line">    UART_BRR1 = <span class="number">0x0D</span>;</span><br><span class="line">    UART_CR2 = (<span class="number">1</span> &lt;&lt; UART_TEN) | (<span class="number">1</span> &lt;&lt; UART_REN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_write</span><span class="params">(<span class="keyword">uint8_t</span> data)</span> </span>&#123;</span><br><span class="line">    UART_DR = data;</span><br><span class="line">    <span class="keyword">while</span> (!(UART_SR &amp; (<span class="number">1</span> &lt;&lt; UART_TC)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> uart_read() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!(UART_SR &amp; (<span class="number">1</span> &lt;&lt; UART_RXNE)));</span><br><span class="line">    <span class="keyword">return</span> UART_DR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redirecting <code>stdout</code> is easy with SDCC.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    uart_write(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’re all set and we can use <code>printf()</code> for debugging.</p>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>Next, we implement SPI master. SPI is quite an easy peripheral and is usually implemented as a simple shift-register in hardware. We need to define only 4 registers to start working with SPI.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPI */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_CR1     _SFR_(0x200)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPE         6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BR0         3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSTR        2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_CR2     _SFR_(0x201)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSM         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSI         0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_SR      _SFR_(0x203)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSY         7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TXE         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RXNE        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DR      _SFR_(0x204)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Chip select */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CS_PIN      4</span></span><br></pre></td></tr></table></figure>

<p>Let’s implement initialization and read&#x2F;write functions. Reading from SPI is achieved by writing a dummy byte, so we’ll hardcode <code>SPI_write(0xFF)</code> inside our <code>SPI_read()</code> function. Chip select pin will be managed in software.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SPI pinout:</span></span><br><span class="line"><span class="comment"> * SCK  -&gt; PC5</span></span><br><span class="line"><span class="comment"> * MOSI -&gt; PC6</span></span><br><span class="line"><span class="comment"> * MISO -&gt; PC7</span></span><br><span class="line"><span class="comment"> * CS   -&gt; PC4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Initialize CS pin */</span></span><br><span class="line">    PC_DDR |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">    PC_CR1 |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">    PC_ODR |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize SPI master at 500kHz  */</span></span><br><span class="line">    SPI_CR2 = (<span class="number">1</span> &lt;&lt; SSM) | (<span class="number">1</span> &lt;&lt; SSI);</span><br><span class="line">    SPI_CR1 = (<span class="number">1</span> &lt;&lt; MSTR) | (<span class="number">1</span> &lt;&lt; SPE) | (<span class="number">1</span> &lt;&lt; BR0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI_write</span><span class="params">(<span class="keyword">uint8_t</span> data)</span> </span>&#123;</span><br><span class="line">    SPI_DR = data;</span><br><span class="line">    <span class="keyword">while</span> (!(SPI_SR &amp; (<span class="number">1</span> &lt;&lt; TXE)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> SPI_read() &#123;</span><br><span class="line">    SPI_write(<span class="number">0xFF</span>);</span><br><span class="line">    <span class="keyword">while</span> (!(SPI_SR &amp; (<span class="number">1</span> &lt;&lt; RXNE)));</span><br><span class="line">    <span class="keyword">return</span> SPI_DR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chip_select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PC_ODR &amp;= ~(<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chip_deselect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PC_ODR |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To test our implementation I’ve written a simple loop that transmits some data.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SPI_init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        chip_select();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0xAA</span>; i &lt; <span class="number">0xFA</span>; i += <span class="number">0x10</span>)</span><br><span class="line">            SPI_write(i);</span><br><span class="line">        chip_deselect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s hook up the logic analyzer and have a look.</p>
<img src="/blog/bare-metal-programming-stm8/spi_master.png" alt="SPI transmission" title="SPI transmission">

<p>Hmm.. something is wrong. It seems that we release chip select too early and the last byte will not be received by a slave device. This can only occur if the SPI peripheral didn’t have enough time to finish transmitting before we released CS pin.</p>
<p>That wasn’t supposed to happen - we are polling for <code>TXE</code> bit, aren’t we? Well, the problem is that <code>TXE</code> only indicates that Tx buffer is empty. It doesn’t tell us that all the bits were shifted out by the shift register. So in order to properly end the transmission we have to check for <code>BSY</code> flag, which tells us whether or not SPI has finished an operation. Let’s modify our <code>chip_deselect()</code> function to take that into account.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chip_deselect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((SPI_SR &amp; (<span class="number">1</span> &lt;&lt; BSY)));</span><br><span class="line">    PC_ODR |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Final output.</p>
<img src="/blog/bare-metal-programming-stm8/spi_master_fixed.png" alt="SPI fixed" title="SPI fixed">

<p>Our final test is the good old “Nokia 5110” LCD. Complete source is on <a target="_blank" rel="noopener" href="https://github.com/lujji/stm8-bare-min/tree/master/examples/SPI_LCD">github</a>.</p>
<img src="/blog/bare-metal-programming-stm8/nokia_lcd.jpg" alt="Nokia LCD" title="Nokia LCD">

<h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><p>Now let’s get onto something more serious. I2C usually requires a bit more work to get it up and running comparing to SPI and UART. I2C has a lot of associated registers, so I will no longer list them from this point. You can find a header with register definitions <a target="_blank" rel="noopener" href="https://github.com/lujji/stm8-bare-min/blob/master/stm8/stm8s.h">here</a>.</p>
<p>Let’s take a look at what the reference manual says about receive and transmit operations.</p>
<img src="/blog/bare-metal-programming-stm8/i2c.svg" alt="I2C transmit and receive modes" title="I2C transmit and receive modes">

<p>That does seem quite complicated: a lot of events are generated during communication. However, we don’t have to explicitly take care of every single event in order to have a working communication - some of the events are automatically cleared by hardware and some may just be ignored and left unattended. We’ll go with the easiest implementation.</p>
<p>We start by implementing initialization and IO functions. We also need dedicated functions to generate start and stop conditions.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I2C pinout:</span></span><br><span class="line"><span class="comment"> * SCL -&gt; PB4</span></span><br><span class="line"><span class="comment"> * SDA -&gt; PB5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    I2C_FREQR = (<span class="number">1</span> &lt;&lt; I2C_FREQR_FREQ1);</span><br><span class="line">    I2C_CCRL = <span class="number">0x0A</span>; <span class="comment">// 100kHz</span></span><br><span class="line">    I2C_OARH = (<span class="number">1</span> &lt;&lt; I2C_OARH_ADDMODE); <span class="comment">// 7-bit addressing</span></span><br><span class="line">    I2C_CR1 = (<span class="number">1</span> &lt;&lt; I2C_CR1_PE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_START);</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_SB)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_STOP);</span><br><span class="line">    <span class="keyword">while</span> (I2C_SR3 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR3_MSL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_write</span><span class="params">(<span class="keyword">uint8_t</span> data)</span> </span>&#123;</span><br><span class="line">    I2C_DR = data;</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_TXE)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> i2c_read(<span class="keyword">uint8_t</span> ack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ack)</span><br><span class="line">        I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        I2C_CR2 &amp;= ~(<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_RXNE)));</span><br><span class="line">    <span class="keyword">return</span> I2C_DR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>According to the reference manual, writing slave address is a special case so we can’t simply use <code>i2c_write()</code> to do that. We need a dedicated function for this purpose.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_write_addr</span><span class="params">(<span class="keyword">uint8_t</span> addr)</span> </span>&#123;</span><br><span class="line">    I2C_DR = addr;</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_ADDR)));</span><br><span class="line">    (<span class="keyword">void</span>) I2C_SR3; <span class="comment">// clear EV6</span></span><br><span class="line">    I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference manual says we are supposed to to handle EV6 event after writing slave address: <em>“EV6: ADDR&#x3D;1, cleared by reading SR1 register followed by reading SR3”</em>. After polling for <code>ADDR</code> bit we simply read <code>SR3</code> register. I’m not sure why this is required, probably to check for BUS_BUSY, but that seemed a bit pointless so we cheated a little.</p>
<p>Now, let’s test our library with an HMC5883L magnetometer. First we define R&#x2F;W flags and some magnetometer related stuff:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_READ            0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_WRITE           0x00</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HMC5883_ADDR        (0x1E <span class="meta-string">&lt;&lt; 1)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_CR_A        0x00</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_CR_B        0x01</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_MODE        0x02</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_DATA_OUT    0x03</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_ID_REG_A    0x0A</span></span></span><br></pre></td></tr></table></figure>

<p>We’ll implement a simple function that reads the device Id and sends it over UART.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmc5883_get_id</span><span class="params">(<span class="keyword">uint8_t</span> *id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Tell device we want to read ID_REG_A */</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_write_addr(HMC5883_ADDR + I2C_WRITE);</span><br><span class="line">    i2c_write(HMC5883_ID_REG_A);</span><br><span class="line">    i2c_stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read ID bytes */</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_write_addr(HMC5883_ADDR + I2C_READ);</span><br><span class="line">    id[<span class="number">0</span>] = i2c_read(<span class="number">1</span>);</span><br><span class="line">    id[<span class="number">1</span>] = i2c_read(<span class="number">1</span>);</span><br><span class="line">    id[<span class="number">2</span>] = i2c_read(<span class="number">0</span>);</span><br><span class="line">    i2c_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> id[<span class="number">3</span>];</span><br><span class="line">    uart_init();</span><br><span class="line">    i2c_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hmc5883_get_id(id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Device ID: %c%c%c\n&quot;</span>, id[<span class="number">0</span>], id[<span class="number">1</span>], id[<span class="number">2</span>]);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Device ID: H43</span><br></pre></td></tr></table></figure>

<p>All seems to work fine, but let’s take a look at the logic analyzer just to make sure.</p>
<img src="/blog/bare-metal-programming-stm8/i2c_screenshot.png" alt="I2C receiver (broken)" title="I2C receiver (broken)">

<p>Hmm.. we do receive correct bytes, but what’s the deal with that 0xFF received right after the NACK? It seems that something is wrong with our code. Time to RTFM.</p>
<h3 id="The-Proper-Way"><a href="#The-Proper-Way" class="headerlink" title="The Proper Way"></a>The Proper Way</h3><p>So the first problem is how we generate STOP condition. According to the documentation, we are supposed to generate STOP <em>before</em> reading the last byte. I changed the code but it didn’t fix the problem. The real problem was that I was porting the magnetometer driver which I wrote for a different microcontroller, so I <em>expected</em> the I2C peripheral to work in a certain way. Well, I was wrong.</p>
<p>The <code>i2c_read()</code> function is supposed to receive only 1 byte of data. It turns out there are 3 different scenarios for N&#x3D;1, N&#x3D;2 and N&gt;2, where N is the number of received bytes. We can’t simply use the function for N&#x3D;1 to read more than a single byte. That means we need separate functions to handle each case! I wonder how many logic gates were dedicated to implement I2C peripheral on this MCU… <em>(Note: I2C implementation on STM32F1xx series is actually identical to STM8.)</em></p>
<p>Looking at the reference manual I figured that we could possibly combine N&#x3D;2 and N&gt;2 cases and handle them with a single function. Below are proper implementations of I2C receive functions.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> i2c_read() &#123;</span><br><span class="line">    I2C_CR2 &amp;= ~(<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">    i2c_stop();</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_RXNE)));</span><br><span class="line">    <span class="keyword">return</span> I2C_DR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_read_buf</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">        <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_RXNE)));</span><br><span class="line">        *(buf++) = I2C_DR;</span><br><span class="line">    &#125;</span><br><span class="line">    *buf = i2c_read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s update our code for reading device Id.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmc5883_get_id</span><span class="params">(<span class="keyword">uint8_t</span> *id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Tell device we want to read ID_REG_A */</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_write_addr(HMC5883_ADDR + I2C_WRITE);</span><br><span class="line">    i2c_write(HMC5883_ID_REG_A);</span><br><span class="line">    i2c_stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read ID bytes */</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_write_addr(HMC5883_ADDR + I2C_READ);</span><br><span class="line">    i2c_read_buf(id, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that our <code>i2c_read_buf()</code> function generates STOP so we no longer have to call <code>i2c_stop()</code> manually. Let’s take a look at the logic analyzer now.</p>
<img src="/blog/bare-metal-programming-stm8/i2c_fixed_screenshot.png" alt="I2C fixed" title="I2C fixed">

<p>Great, no 0xFF at the end! Now we’re ready to move onto something different.</p>
<h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><p>Nothing exciting about the ADC on STM8: 10-bit resolution, single and continuous conversion modes, configurable prescaler.. all the usual boring stuff. There is also a data buffer that can hold a number of ADC samples, which is rather convenient.</p>
<p>The default <code>printf()</code> implementation provided by SDCC does not support floats. To enable floating point output, <code>printf_large.c</code> needs to be recompiled with <code>-DUSE_FLOATS=1</code> option. For this example we are going to cheat and print the results in millivolts instead. Without further ado, let’s write some code for single ADC conversion.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V_REF 3.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> ADC_read() &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> adcH, adcL;</span><br><span class="line">    ADC1_CR1 |= (<span class="number">1</span> &lt;&lt; ADC1_CR1_ADON);</span><br><span class="line">    <span class="keyword">while</span> (!(ADC1_CSR &amp; (<span class="number">1</span> &lt;&lt; ADC1_CSR_EOC)));</span><br><span class="line">    adcL = ADC1_DRL;</span><br><span class="line">    adcH = ADC1_DRH;</span><br><span class="line">    ADC1_CSR &amp;= ~(<span class="number">1</span> &lt;&lt; ADC1_CSR_EOC); <span class="comment">// Clear EOC flag</span></span><br><span class="line">    <span class="keyword">return</span> (adcL | (adcH &lt;&lt; <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Configure ADC channel 4 (PD3)  */</span></span><br><span class="line">    ADC1_CSR |= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* Right-align data */</span></span><br><span class="line">    ADC1_CR2 |= (<span class="number">1</span> &lt;&lt; ADC1_CR2_ALIGN);</span><br><span class="line">    <span class="comment">/* Wake ADC from power down */</span></span><br><span class="line">    ADC1_CR1 |= <span class="number">1</span> &lt;&lt; ADC1_CR1_ADON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ADC_init();</span><br><span class="line">    uart_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> val = ADC_read();</span><br><span class="line">        <span class="keyword">float</span> voltage = (V_REF / <span class="number">1024.0</span>) * val * <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Channel4: %d mV\n&quot;</span>, (<span class="keyword">uint16_t</span>) voltage);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pretty straight forward. Note that <code>EOC</code> flag has to be manually cleared by software.</p>
<p>A few things that should be taken into account when working with ADC:</p>
<ul>
<li>The order in which <code>DRL</code> and <code>DRH</code> registers are accessed depends on data alignment.</li>
<li>ADC has no internal voltage reference. STM8S003 does not have an external Vref pin, so it is tied to Vcc internally, which means that your supply voltage has to be spot-on for any serious measurements.</li>
<li>Data buffer registers have no internal locking. ST provides an assembly snippet in the datasheet for reading buffer registers.</li>
</ul>
<h3 id="Timers-and-interrupts"><a href="#Timers-and-interrupts" class="headerlink" title="Timers and interrupts"></a>Timers and interrupts</h3><p>You can’t get far without using timers and interrupts, which is what this last section will cover. STM8S003 has 16-bit ‘advanced control’ as well as 8-bit general-purpose timers. TIM1 is a really complicated peripheral with 32 dedicated registers, and covering it’s functionality would probably require a few extra articles. For this article, we’ll use TIM4 which is good enough for basic applications.</p>
<p>There isn’t much to tweak inside TIM4: it contains an 8-bit auto-reload up counter, 3-bit prescaler and an option to generate interrupt on counter overflow.</p>
<p>The prescaler divides counter clock frequency by a power of 2 from 1 to 128 depending on <code>PSCR</code> registers:</p>
<img src="/blog/bare-metal-programming-stm8/timer_prescaler.svg" alt="""" title="""">

<p>In this example we are going to toggle a pin each time the counter matches value in the <code>ARR</code> register. The frequency of the waveform generated by our IO pin is calculated as follows:</p>
<img src="/blog/bare-metal-programming-stm8/timer_f_io.svg" alt="""" title="""">

<p>To achieve a frequency of 100Hz <code>ARR</code> has to be set to 77, given that our clock frequency is 2MHz. We need to enable Update Interrupt for <code>TIM4</code>, but before that interrupts must be enabled globally by executing <code>rim</code> instruction.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Enable interrupts */</span></span><br><span class="line">    <span class="keyword">__asm__</span>(<span class="string">&quot;rim&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set PD3 as output */</span></span><br><span class="line">    PD_DDR |= (<span class="number">1</span> &lt;&lt; OUTPUT_PIN);</span><br><span class="line">    PD_CR1 |= (<span class="number">1</span> &lt;&lt; OUTPUT_PIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prescaler = 128 */</span></span><br><span class="line">    TIM4_PSCR = <span class="number">0b00000111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Period = 5ms */</span></span><br><span class="line">    TIM4_ARR = <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line">    TIM4_IER |= (<span class="number">1</span> &lt;&lt; TIM4_IER_UIE); <span class="comment">// Enable Update Interrupt</span></span><br><span class="line">    TIM4_CR1 |= (<span class="number">1</span> &lt;&lt; TIM4_CR1_CEN); <span class="comment">// Enable TIM4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Loop forever */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Now, when I said that we’re going to implement everything from scratch, I wasn’t completely honest. We’re still using some start-up code which initializes the stack and interrupt vector table. If you look at the listing you can see that SDCC has generated the interrupt table for us:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">000000 82v00u00u00             37         int s_GSINIT ;reset</span><br><span class="line">000004 82 00 00 00             38         int 0x0000 ;trap</span><br><span class="line">000008 82 00 00 00             39         int 0x0000 ;int0</span><br><span class="line">...</span><br><span class="line">00007C 82 00 00 00             68         int 0x0000 ;int29</span><br></pre></td></tr></table></figure>

<p>Registering an interrupt handler is easy with SDCC: there is a special attribute <code>_interrupt()</code> which takes interrupt number as a parameter. Section 7 (‘Interrupt vector mapping’) of the datasheet describes which IRQ number corresponds to which peripheral. For TIM4 it is 23. Our interrupt handler will look like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIM4_ISR 23</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_isr</span><span class="params">(<span class="keyword">void</span>)</span> __<span class="title">interrupt</span><span class="params">(TIM4_ISR)</span> </span>&#123;</span><br><span class="line">    PD_ODR ^= (<span class="number">1</span> &lt;&lt; OUTPUT_PIN);</span><br><span class="line">    TIM4_SR &amp;= ~(<span class="number">1</span> &lt;&lt; UIF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p>We have enough building blocks - now it’s time to put them together into some ‘real-world’ application. For this demo I picked up <a target="_blank" rel="noopener" href="http://www.nxp.com/assets/documents/data/en/data-sheets/MMA8452Q.pdf">MMA8452</a> 3-axis I2C accelerometer and a standard <a target="_blank" rel="noopener" href="https://www.sparkfun.com/datasheets/LCD/HD44780.pdf">HD44780</a> 1602 LCD, which is extremely popular among electronics enthusiasts for some reason.</p>
<p>The demo application will calculate inclination angle based on accelerometer readings and output it to the LCD. Calculating inclination angle will require some trigonometry and floating point arithmetic, which will consume a good amount of resources. Despite the floating point operations being quite slow, STM8 managed this task decently.</p>
<img src="/blog/bare-metal-programming-stm8/demo.jpg" alt="Demo" title="Demo">

<p>You might have noticed the lack of contrast adjustment potentiometer. The LCD module that I’m using is rated for 5V, however my setup uses 3.3V supply. I couldn’t be bothered with a separate supply for the display, so I cheated: the LCD is initialized in 1-line mode, which results in 1&#x2F;8 duty cycle, and <code>Vo</code> pin is tied to ground.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>STM8 is nice and cheap, but it is really hard to justify using this microcontroller, especially given the fact that price difference between STM8 and low-end Cortex-M0 devices like STM32F03 is negligible. The biggest downside for me was lack of GCC support. Despite SDCC being a reasonably good compiler, it does not fully support C99 and C11 standards, which means that I have to refactor most of my existing code to make it compatible. Code optimization isn’t great either, which is a shame, since most STM8 microcontrollers don’t have a lot of flash to spare.</p>
<p>As always, code is available on <a target="_blank" rel="noopener" href="https://github.com/lujji/stm8-bare-min">github</a>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lujji.github.io/blog/bare-metal-programming-stm8/" data-id="cle467ss60001axcx6o1t8lfz" class="article-share-link">Share</a>
      
        <a href="http://lujji.github.io/blog/bare-metal-programming-stm8/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/bare-metal/" rel="tag">bare-metal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/sdcc/" rel="tag">sdcc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stm8/" rel="tag">stm8</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/bare-metal-programming-stm8-part2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer Posts</strong>
      <div class="article-nav-title">
        
          Bare metal programming: STM8 (Part 2)
        
      </div>
    </a>
  
  
    <a href="/blog/installing-blackmagic-via-stlink-bootloader/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older Posts</strong>
      <div class="article-nav-title">Installing Black Magic via ST-Link bootloader</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/power-analysis-with-ds1000z/">Power analysis with Rigol DS1000Z</a>
          </li>
        
          <li>
            <a href="/blog/serial-bootloader-for-stm8/">Serial bootloader for STM8</a>
          </li>
        
          <li>
            <a href="/blog/mixing-c-and-assembly-on-stm8/">Mixing C and assembly on STM8</a>
          </li>
        
          <li>
            <a href="/blog/executing-code-from-ram-on-stm8/">Executing code from RAM on STM8</a>
          </li>
        
          <li>
            <a href="/blog/bare-metal-programming-stm8-part2/">Bare metal programming: STM8 (Part 2)</a>
          </li>
        
          <li>
            <a href="/blog/bare-metal-programming-stm8/">Bare metal programming: STM8</a>
          </li>
        
          <li>
            <a href="/blog/installing-blackmagic-via-stlink-bootloader/">Installing Black Magic via ST-Link bootloader</a>
          </li>
        
          <li>
            <a href="/blog/esp-httpd/">HTTP server with WebSockets on ESP8266</a>
          </li>
        
          <li>
            <a href="/blog/reverse-engineering-stlink-firmware-part2/">Reverse-engineering ST-Link firmware - Part 2</a>
          </li>
        
          <li>
            <a href="/blog/reverse-engineering-stlink-firmware/">Reverse-engineering ST-Link firmware</a>
          </li>
        
          <li>
            <a href="/blog/stlink-clone-trace/">Adding Trace support to ST-Link clones</a>
          </li>
        
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 lujji<br>      
      lujji at protonmail com
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'lujji';
  
  var disqus_url = 'http://lujji.github.io/blog/bare-metal-programming-stm8/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>


  </div>
</body>
</html>