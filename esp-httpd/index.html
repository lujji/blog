<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HTTP server with WebSockets on ESP8266 | lujji</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="This article will cover implementing a basic HTTP server on top of LwIP for ESP8266 and dive into the implementation of WebSockets.">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP server with WebSockets on ESP8266">
<meta property="og:url" content="http://lujji.github.io/blog/esp-httpd/index.html">
<meta property="og:site_name" content="lujji">
<meta property="og:description" content="This article will cover implementing a basic HTTP server on top of LwIP for ESP8266 and dive into the implementation of WebSockets.">
<meta property="og:image" content="http://lujji.github.io/blog/blog/esp-httpd/hardware.jpg">
<meta property="og:image" content="http://lujji.github.io/blog/blog/esp-httpd/http_test.png">
<meta property="og:image" content="http://lujji.github.io/blog/blog/esp-httpd/http_test2.png">
<meta property="og:image" content="http://lujji.github.io/blog/blog/esp-httpd/websocket_demo.png">
<meta property="og:updated_time" content="2017-02-04T16:01:36.291Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HTTP server with WebSockets on ESP8266">
<meta name="twitter:description" content="This article will cover implementing a basic HTTP server on top of LwIP for ESP8266 and dive into the implementation of WebSockets.">
<meta name="twitter:image" content="http://lujji.github.io/blog/blog/esp-httpd/hardware.jpg">
  
    <link rel="alternate" href="atom.xml" title="lujji" type="application/atom+xml">
  
  
    <link rel="icon" href="/blog/css/images/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">lujji</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">embedded stuff</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
      <a id="nav-github-link" class="nav-icon" href="https://github.com/lujji" title="GitHub"></a>
        
          <a id="nav-rss-link" class="nav-icon" href="atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//duckduckgo.com" method="get" accept-charset="UTF-8" onsubmit="var qstr = document.getElementById('searchBox'); qstr.value += ' site:http://lujji.github.io/blog'" class="search-form"><input id="searchBox" type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-esp-httpd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/esp-httpd/" class="article-date">
  <time datetime="2017-01-30T20:11:00.000Z" itemprop="datePublished">2017-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HTTP server with WebSockets on ESP8266
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This article will cover implementing a basic HTTP server on top of LwIP for ESP8266 and dive into the implementation of WebSockets.</p>
<a id="more"></a>
<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>ESP8266 is an extremely popular device. Chances are, at some point you even bought a few modules for some “future project”. That’s exactly what I did, and for a long time I didn’t find any application for this device.</p>
<h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents:"></a>Contents:</h2><ul>
<li><a href="#The-Hardware">The Hardware</a></li>
<li><a href="#Simple-HTTP-server">Simple HTTP server</a></li>
<li><a href="#WebSockets">WebSockets</a><br>– <a href="#Opening-handshake">Opening handshake</a><br>– <a href="#Transmitting-data">Transmitting data</a><br>– <a href="#Closing-connection">Closing connection</a></li>
<li><a href="#Demo">Demo</a></li>
</ul>
<hr>
<h2 id="The-Hardware"><a href="#The-Hardware" class="headerlink" title="The Hardware"></a>The Hardware</h2><p>At first glance, ESP8266 looks quite attractive: 32-bit processor, decent amount of RAM, up to 4MB external flash for user code. But once you dive into the specifics of the device, you immediately start facing it’s problems: the documentation is rather scarce, power consumption is about 80mA during normal operation, which is a problem for battery-powered applications, and even though you can have a large external flash, the ESP8266 can only map 1 megabyte of flash into execution space. The rest of the flash may be used for firmware updates and data storage. Overall, the device itself does not instill a lot of confidence. But hey.. it’s cheap.</p>
<img src="/blog/esp-httpd/hardware.jpg" alt="ESP8266" title="ESP8266">
<p>To get the module up and running we need a 3V3 supply rail and a UART-USB converter for programming. Apart from Rx/Tx the following lines need to be connected from the serial cable to the module:</p>
<p><code>RTS</code> -&gt; <code>Reset</code><br><code>DTR</code> -&gt; <code>Boot/GPIO0</code><br><code>3V3</code> -&gt; <code>CH_PD</code></p>
<p>ESP-12E modules already have a pull-up resistor on reset line. Optionally, a pull-up should be installed on <code>GPIO0</code>.</p>
<p>As for the software, there are two versions of SDK from Espressif - one of them is based on FreeRTOS and the other one is based on callbacks. It seems that most development occurs around the non-RTOS version of SDK. At the moment of writing this post, the latest FreeRTOS version provided by Espressif SDK seems to be 7.5.2, while the latest upstream version is 9.0.0. Luckily, <a href="https://github.com/SuperHouse/esp-open-rtos" target="_blank" rel="external">esp-open-rtos</a> addresses this issue. It is a community-developed framework based on the latest version of FreeRTOS, which aims to provide open-source alternatives to the binary blobs of the Espressif SDK.</p>
<h2 id="Simple-HTTP-server"><a href="#Simple-HTTP-server" class="headerlink" title="Simple HTTP server"></a>Simple HTTP server</h2><p>To get a better understanding of how things work, let’s implement the most basic HTTP server. First we need to create a new task called <code>httpd_task</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xTaskCreate(&amp;httpd_task, <span class="string">"http_server"</span>, <span class="number">1024</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<p>We are going to use LwIP’s <code>netconn</code> API for our demo, <code>&lt;lwip/api.h&gt;</code> needs to be included.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">httpd_task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> netconn *client = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> netconn *nc = netconn_new(NETCONN_TCP);</div><div class="line">    <span class="keyword">if</span> (nc == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to allocate socket\n"</span>);</div><div class="line">        vTaskDelete(<span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    netconn_bind(nc, IP_ADDR_ANY, <span class="number">80</span>);</div><div class="line">    netconn_listen(nc);</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">err_t</span> err = netconn_accept(nc, &amp;client);</div><div class="line">        <span class="keyword">if</span> (err == ERR_OK) &#123;</div><div class="line">            <span class="keyword">struct</span> netbuf *nb;</div><div class="line">            <span class="keyword">if</span> ((err = netconn_recv(client, &amp;nb)) == ERR_OK) &#123;</div><div class="line">                <span class="keyword">void</span> *data;</div><div class="line">                <span class="keyword">u16_t</span> len;</div><div class="line">                netbuf_data(nb, &amp;data, &amp;len);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Received data:\n%.*s\n"</span>, len, (<span class="keyword">char</span>*) data);</div><div class="line">                <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf),</div><div class="line">                        <span class="string">"HTTP/1.1 200 OK\r\n"</span></div><div class="line">                        <span class="string">"Content-type: text/html\r\n\r\n"</span></div><div class="line">                        <span class="string">"Test"</span>);</div><div class="line">                netconn_write(client, buf, <span class="built_in">strlen</span>(buf), NETCONN_COPY);</div><div class="line">            &#125;</div><div class="line">            netbuf_delete(nb);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Closing connection\n"</span>);</div><div class="line">        netconn_close(client);</div><div class="line">        netconn_delete(client);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The code is pretty straight-forward: we create a new <code>netconn</code>, bind it to port 80 (which is used for HTTP) and start listening for incoming TCP connections. In the main loop of the task we call a blocking function <code>netconn_accept()</code>. Once the connection from client is accepted we log the request to console and generate a response. Response contains a minimal header that is enough for the browser to treat anything after <code>\r\n\r\n</code> as an HTML page.</p>
<img src="/blog/esp-httpd/http_test.png" alt="Hello, world" title="Hello, world">
<p>When browser requests a page it sends a <code>GET</code> request, which looks like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Host: 192.168.100.4</div><div class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: en-US,en;q=0.5</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
<p>We’re only interested in the first line that contains the URI. To make things a bit more interesting we are going to extract the URI and switch the LED on the device when particular address is requested. We’ll also add some page content just for kicks.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">httpd_task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> netconn *client = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> netconn *nc = netconn_new(NETCONN_TCP);</div><div class="line">    <span class="keyword">if</span> (nc == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to allocate socket.\n"</span>);</div><div class="line">        vTaskDelete(<span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    netconn_bind(nc, IP_ADDR_ANY, <span class="number">80</span>);</div><div class="line">    netconn_listen(nc);</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *webpage = &#123;</div><div class="line">        <span class="string">"HTTP/1.1 200 OK\r\n"</span></div><div class="line">        <span class="string">"Content-type: text/html\r\n\r\n"</span></div><div class="line">        <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Server&lt;/title&gt;"</span></div><div class="line">        <span class="string">"&lt;style&gt; div.main &#123;"</span></div><div class="line">        <span class="string">"font-family: Arial;"</span></div><div class="line">        <span class="string">"padding: 0.01em 16px;"</span></div><div class="line">        <span class="string">"box-shadow: 2px 2px 1px 1px #d2d2d2;"</span></div><div class="line">        <span class="string">"background-color: #f1f1f1;&#125;"</span></div><div class="line">        <span class="string">"&lt;/style&gt;&lt;/head&gt;"</span></div><div class="line">        <span class="string">"&lt;body&gt;&lt;div class='main'&gt;"</span></div><div class="line">        <span class="string">"&lt;h3&gt;HTTP Server&lt;/h3&gt;"</span></div><div class="line">        <span class="string">"&lt;p&gt;URL: %s&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;p&gt;Uptime: %d seconds&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;p&gt;Free heap: %d bytes&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;button onclick=\"location.href='/on'\" type='button'&gt;"</span></div><div class="line">        <span class="string">"LED On&lt;/button&gt;&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;button onclick=\"location.href='/off'\" type='button'&gt;"</span></div><div class="line">        <span class="string">"LED Off&lt;/button&gt;&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">/* disable LED */</span></div><div class="line">    gpio_enable(<span class="number">2</span>, GPIO_OUTPUT);</div><div class="line">    gpio_write(<span class="number">2</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">err_t</span> err = netconn_accept(nc, &amp;client);</div><div class="line">        <span class="keyword">if</span> (err == ERR_OK) &#123;</div><div class="line">            <span class="keyword">struct</span> netbuf *nb;</div><div class="line">            <span class="keyword">if</span> ((err = netconn_recv(client, &amp;nb)) == ERR_OK) &#123;</div><div class="line">                <span class="keyword">void</span> *data;</div><div class="line">                <span class="keyword">u16_t</span> len;</div><div class="line">                netbuf_data(nb, &amp;data, &amp;len);</div><div class="line"></div><div class="line">                <span class="comment">/* check for a GET request */</span></div><div class="line">                <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(data, <span class="string">"GET "</span>, <span class="number">4</span>)) &#123;</div><div class="line">                    <span class="keyword">char</span> uri[<span class="number">16</span>];</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> max_uri_len = <span class="number">16</span>;</div><div class="line">                    <span class="keyword">char</span> *sp1, *sp2;</div><div class="line"></div><div class="line">                    <span class="comment">/* extract URI */</span></div><div class="line">                    sp1 = data + <span class="number">4</span>;</div><div class="line">                    sp2 = <span class="built_in">memchr</span>(sp1, <span class="string">' '</span>, max_uri_len);</div><div class="line">                    <span class="keyword">int</span> len = sp2 - sp1;</div><div class="line">                    <span class="built_in">memcpy</span>(uri, sp1, len);</div><div class="line">                    uri[len] = <span class="string">'\0'</span>;</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"uri: %s\n"</span>, uri);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(uri, <span class="string">"/on"</span>, max_uri_len))</div><div class="line">                        gpio_write(<span class="number">2</span>, <span class="literal">false</span>);</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(uri, <span class="string">"/off"</span>, max_uri_len))</div><div class="line">                        gpio_write(<span class="number">2</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line">                    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), webpage,</div><div class="line">                            uri,</div><div class="line">                            xTaskGetTickCount() * portTICK_PERIOD_MS / <span class="number">1000</span>,</div><div class="line">                            (<span class="keyword">int</span>) xPortGetFreeHeapSize());</div><div class="line">                    netconn_write(client, buf, <span class="built_in">strlen</span>(buf), NETCONN_COPY);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            netbuf_delete(nb);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Closing connection\n"</span>);</div><div class="line">        netconn_close(client);</div><div class="line">        netconn_delete(client);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we have a slightly more interactive server.</p>
<img src="/blog/esp-httpd/http_test2.png" alt="Simple HTTP server" title="Simple HTTP server">
<p>In case your application needs to serve a simple web-page, this approach might be just good enough.</p>
<p>Although implementing an HTTP server from scratch could be a good exercise, I didn’t find it very exciting, so instead of reinventing the wheel I decided to find one that is round enough for my needs.</p>
<p>For my application I decided to use <a href="http://www.nongnu.org/lwip/2_0_0/group__httpd.html" target="_blank" rel="external">httpd</a> from LwIP/contrib. This server is based on callbacks, so it should work with RTOS and non-RTOS SDK.</p>
<h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><p>WebSocket is a protocol which allows full-duplex communication between client (like web-browser) and server. This means that we can send small messages back and forth for doing things like toggling pins and reading sensor data without having to refresh the web-page and transfer large amounts of HTTP data all the time. We’ll have to resort to HTTP only once for the opening handshake, after that all the communication is happening on the TCP layer. Everything we need to know in order to implement WebSocket protocol is described in <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external">RFC 6455</a>.</p>
<h3 id="Opening-handshake"><a href="#Opening-handshake" class="headerlink" title="Opening handshake"></a>Opening handshake</h3><p>Probably the hardest part. When client wants to open a WebSocket it sends a specific GET request:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</div></pre></td></tr></table></figure>
<p>The server should generate the following response:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</div></pre></td></tr></table></figure>
<p>The procedure to generate <code>Sec-WebSocket-Accept</code> part is as follows:</p>
<ol>
<li>Take the <code>Sec-WebSocket-Key</code> part</li>
<li>Concatenate it with GUID which is “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”</li>
<li>Calculate SHA-1 hash of the resulting string</li>
<li>Encode hash in base-64 and send to the client</li>
</ol>
<p>Let’s first define some necessary constants inside <code>httpd.c</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_HEADER[] = <span class="string">"Upgrade: websocket\r\n"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_GUID[] = <span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_KEY[] = <span class="string">"Sec-WebSocket-Key: "</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_RSP[] = <span class="string">"HTTP/1.1 101 Switching Protocols\r\n"</span> \</div><div class="line">                      <span class="string">"Upgrade: websocket\r\n"</span> \</div><div class="line">                      <span class="string">"Connection: Upgrade\r\n"</span> \</div><div class="line">                      <span class="string">"Sec-WebSocket-Accept: %s\r\n\r\n"</span>;</div></pre></td></tr></table></figure>
<p>According to the HTTP specification, comparison of fields like <code>WS_HEADER</code> should be case-insensitive. Despite that, we’ll use standard <code>strnstr()</code> function, since most browsers follow the convention and generate requests as defined above.</p>
<p>We’ll need to alter <code>http_parse_request()</code> function to support opening handshake. In this context <code>data</code> is the incoming TCP buffer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (strnstr(data, WS_HEADER, data_len)) &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoded_key[<span class="number">32</span>];</div><div class="line">    <span class="keyword">char</span> key[<span class="number">64</span>];</div><div class="line">    <span class="keyword">char</span> *key_start = strnstr(data, WS_KEY, data_len);</div><div class="line">    <span class="keyword">if</span> (key_start) &#123;</div><div class="line">        key_start += <span class="number">19</span>;</div><div class="line">        <span class="keyword">char</span> *key_end = strnstr(key_start, <span class="string">"\r\n"</span>, data_len);</div><div class="line">        <span class="keyword">if</span> (key_end) &#123;</div><div class="line">            <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (key_end - key_start);</div><div class="line">            <span class="keyword">if</span> (len + <span class="keyword">sizeof</span>(WS_GUID) &lt; <span class="keyword">sizeof</span>(key) &amp;&amp; len &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">/* Concatenate key */</span></div><div class="line">                <span class="built_in">memcpy</span>(key, key_start, len);</div><div class="line">                strlcpy(&amp;key[len], WS_GUID, <span class="keyword">sizeof</span>(key));</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Resulting key: %s\n"</span>, key);</div><div class="line"></div><div class="line">                <span class="comment">/* Get SHA1 */</span></div><div class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> sha1sum[<span class="number">20</span>];</div><div class="line">                mbedtls_sha1((<span class="keyword">unsigned</span> <span class="keyword">char</span> *) key, <span class="keyword">sizeof</span>(WS_GUID) + len - <span class="number">1</span>, sha1sum);</div><div class="line"></div><div class="line">                <span class="comment">/* Base64 encode */</span></div><div class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> olen;</div><div class="line">                mbedtls_base64_encode(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;olen, sha1sum, <span class="number">20</span>); <span class="comment">//get length</span></div><div class="line">                <span class="keyword">int</span> ok = mbedtls_base64_encode(encoded_key, <span class="keyword">sizeof</span>(encoded_key), &amp;olen, sha1sum, <span class="number">20</span>);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (ok == <span class="number">0</span>) &#123;</div><div class="line">                    hs-&gt;is_websocket = <span class="number">1</span>;</div><div class="line">                    encoded_key[olen] = <span class="string">'\0'</span>;</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"Base64 encoded: %s\n"</span>, encoded_key);</div><div class="line"></div><div class="line">                    <span class="comment">/* Send response */</span></div><div class="line">                    <span class="keyword">char</span> buf[<span class="number">256</span>];</div><div class="line">                    <span class="keyword">u16_t</span> len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), WS_RSP, encoded_key);</div><div class="line">                    http_write(pcb, buf, &amp;len, TCP_WRITE_FLAG_COPY);</div><div class="line">                    <span class="keyword">return</span> ERR_OK;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Key overflow\n"</span>);</div><div class="line">                <span class="keyword">return</span> ERR_MEM;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Malformed packet\n"</span>);</div><div class="line">        <span class="keyword">return</span> ERR_ARG;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Note: I’m using <code>sizeof(buf)</code> quite often to get the array length at compile-time. In this case it works as expected due to the fact that <code>buf</code> is always of char type. A more proper solution is to use <code>sizeof(buf)/sizeof(buf[0])</code> - this way we get the correct result regardless of the data type.</em></p>
<h3 id="Transmitting-data"><a href="#Transmitting-data" class="headerlink" title="Transmitting data"></a>Transmitting data</h3><p>On the client side opening a new WebSocket and listening for incoming messages is just a matter of few lines of javascript:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Open new websocket and register callback */</span></div><div class="line">ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://192.168.54.29"</span>);</div><div class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; onMessage(evt) &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(evt.data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>When server receives data from a client the payload is <em>always</em> masked (assuming that client’s implementation of the protocol is correct), therefore, we need to unmask the payload before passing it to the user callback. <a href="https://tools.ietf.org/html/rfc6455#page-33" target="_blank" rel="external">Masking algorithm</a> is rather trivial.<br>The first byte of the payload contains an opcode. We’re only going to support text or binary modes and close request. We shall omit continuation frames to keep things simple.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> err_t <span class="title">websocket_parse</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="keyword">struct</span> pbuf *p)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data;</div><div class="line">    data = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*) p-&gt;payload;</div><div class="line">    <span class="keyword">u16_t</span> data_len = p-&gt;len;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (data != <span class="literal">NULL</span> &amp;&amp; data_len &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">uint8_t</span> opcode = data[<span class="number">0</span>] &amp; <span class="number">0x0F</span>;</div><div class="line">        <span class="keyword">switch</span> (opcode) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0x01</span>: <span class="comment">// text</span></div><div class="line">            <span class="keyword">case</span> <span class="number">0x02</span>: <span class="comment">// bin</span></div><div class="line">                <span class="keyword">if</span> (data_len &gt; <span class="number">6</span>) &#123;</div><div class="line">                    data_len -= <span class="number">6</span>;</div><div class="line">                    <span class="comment">/* unmask */</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data_len; i++)</div><div class="line">                        data[i + <span class="number">6</span>] ^= data[<span class="number">2</span> + i % <span class="number">4</span>];</div><div class="line">                    <span class="comment">/* user callback */</span></div><div class="line">                    websocket_cb(pcb, &amp;data[<span class="number">6</span>], data_len, opcode);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">0x08</span>: <span class="comment">// close</span></div><div class="line">                <span class="keyword">return</span> ERR_CLSD;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ERR_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ERR_VAL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>When server sends data to the client it is always unmasked. Our implementation won’t support packets larger than 125 bytes for simplicity.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">websocket_write</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">uint16_t</span> len, <span class="keyword">uint8_t</span> mode)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (len &gt; <span class="number">125</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[len + <span class="number">2</span>];</div><div class="line">    buf[<span class="number">0</span>] = <span class="number">0x80</span> | mode;</div><div class="line">    buf[<span class="number">1</span>] = len;</div><div class="line">    <span class="built_in">memcpy</span>(&amp;buf[<span class="number">2</span>], data, len);</div><div class="line">    len += <span class="number">2</span>;</div><div class="line"></div><div class="line">    tcp_write(pcb, buf, len, TCP_WRITE_FLAG_COPY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Closing-connection"><a href="#Closing-connection" class="headerlink" title="Closing connection"></a>Closing connection</h3><p>Simply closing a TCP connection is an option, but it’s considered to be an <em>unclean shutdown</em>. When one side wants to close a websocket, it sends a packet which contains   a reason for closing the connection. The other side then echoes this packet back and the connection is considered closed afterwards. Our implementation shall always close the connection with status code <code>1000</code> (normal closure).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> err_t <span class="title">websocket_close</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> buf[] = &#123;<span class="number">0x88</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0xe8</span>&#125;;</div><div class="line">    <span class="keyword">u16_t</span> len = <span class="keyword">sizeof</span>(buf);</div><div class="line">    <span class="keyword">return</span> tcp_write(pcb, buf, len, TCP_WRITE_FLAG_COPY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>I created a small project to demonstrate basic functionality. In this demo two sockets are used: one for polling by the client, and second one for streaming data from server.</p>
<img src="/blog/esp-httpd/websocket_demo.png" alt="WebSockets demo" title="WebSockets demo">
<p>Code is available on <a href="https://github.com/lujji/esp-httpd" target="_blank" rel="external">github</a>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lujji.github.io/blog/esp-httpd/" data-id="ciyrfgsyb0000qgs60psr0hyj" class="article-share-link">Share</a>
      
        <a href="http://lujji.github.io/blog/esp-httpd/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/esp8266/">esp8266</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/freertos/">freertos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/reverse-engineering-stlink-firmware-part2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Reverse-engineering ST-Link firmware - Part 2</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/esp-httpd/">HTTP server with WebSockets on ESP8266</a>
          </li>
        
          <li>
            <a href="/blog/reverse-engineering-stlink-firmware-part2/">Reverse-engineering ST-Link firmware - Part 2</a>
          </li>
        
          <li>
            <a href="/blog/reverse-engineering-stlink-firmware/">Reverse-engineering ST-Link firmware</a>
          </li>
        
          <li>
            <a href="/blog/stlink-clone-trace/">Adding Trace support to ST-Link clones</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 lujji<br>      
      lujji at protonmail com
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'lujji';
  
  var disqus_url = 'http://lujji.github.io/blog/esp-httpd/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>