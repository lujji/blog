<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Bare metal programming: STM8 (Part 2) | lujji</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="In this part we are going to focus on more features of STM8 (clock, EEPROM, option bytes, flash access) and stick some wires into the mains outlet.">
<meta property="og:type" content="article">
<meta property="og:title" content="Bare metal programming: STM8 (Part 2)">
<meta property="og:url" content="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/index.html">
<meta property="og:site_name" content="lujji">
<meta property="og:description" content="In this part we are going to focus on more features of STM8 (clock, EEPROM, option bytes, flash access) and stick some wires into the mains outlet.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/50hz_clk.jpg">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/schematic.jpg">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/555_schmitt_trigger.png">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/555_edge.png">
<meta property="og:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/spi_50hz.gif">
<meta property="article:published_time" content="2017-04-10T21:00:00.000Z">
<meta property="article:modified_time" content="2017-07-30T00:51:06.000Z">
<meta property="article:author" content="lujji">
<meta property="article:tag" content="bare-metal">
<meta property="article:tag" content="sdcc">
<meta property="article:tag" content="stm8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/50hz_clk.jpg">
  
    <link rel="alternate" href="atom.xml" title="lujji" type="application/atom+xml">
  
  
    <link rel="icon" href="/blog/css/images/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">lujji</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">embedded stuff</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
      <a id="nav-github-link" class="nav-icon" target="_blank" rel="noopener" href="https://github.com/lujji" title="GitHub"></a>
        
          <a id="nav-rss-link" class="nav-icon" href="atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//duckduckgo.com" method="get" accept-charset="UTF-8" onsubmit="var qstr = document.getElementById('searchBox'); qstr.value += ' site:http://lujji.github.io/blog'" class="search-form"><input id="searchBox" type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-bare-metal-programming-stm8-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/bare-metal-programming-stm8-part2/" class="article-date">
  <time datetime="2017-04-10T21:00:00.000Z" itemprop="datePublished">2017-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Bare metal programming: STM8 (Part 2)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In this part we are going to focus on more features of STM8 (clock, EEPROM, option bytes, flash access) and stick some wires into the mains outlet.</p>
<span id="more"></span>

<h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents:"></a>Contents:</h2><ul>
<li><a href="#Clock">Clock</a></li>
<li><a href="#EEPROM">EEPROM</a></li>
<li><a href="#Option-bytes">Option bytes</a></li>
<li><a href="#Flash">Flash</a></li>
</ul>
<h2 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h2><p>STM8 can run on one of 3 different clock sources:</p>
<ul>
<li>External clock&#x2F;crystal oscillator (HSE)</li>
<li>Internal 16 MHz RC oscillator (HSI)</li>
<li>Internal 128 khz RC oscillator (LSI)</li>
</ul>
<p>These clock sources determine the frequency of master clock which clocks the CPU and peripherals. HSI clock can be scaled down by adjusting 2-bit <code>HSIDIV</code> prescaler. At startup the master clock source is automatically selected as HSI &#x2F; 8, which results in 2 MHz. It is possible to decrease CPU frequency by increasing the prescaler value in <code>CPUDIV</code> register. By default the prescaler is set to 1.</p>
<p>In the <a href="/blog/bare-metal-programming-stm8">previous part</a> we didn’t bother configuring clocks and therefore were running at 2 MHz. This time we’ll be using an external crystal connected between PA1 and PA2 pins. Before we start configuring clocks, let’s take advantage of processor’s clock output capability - this will allow us to perform a sanity check and see if we configured things properly.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_LSI_CCO       0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_HSE_CCO       0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_CPU_CCO       0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_HSI_CCO       0x22</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_out_enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Configure PC4 as output */</span></span><br><span class="line">    PC_DDR |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    <span class="comment">/* Push-pull mode, 10MHz output speed */</span></span><br><span class="line">    PC_CR1 |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    PC_CR2 |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    <span class="comment">/* Clock output on PC4 */</span></span><br><span class="line">    CLK_CCOR |= (<span class="number">1</span> &lt;&lt; CLK_CCOR_CCOEN) | F_CPU_CCO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Various clock output options are available in the <code>CLK_CCOR</code> register - I defined some of the possible ones so that you get the idea.</p>
<p>Enabling external oscillator is done by setting <code>HSEEN</code> bit in <code>CLK_ECKR</code> register. As soon as the oscillator is ready (which is indicated by <code>HSERDY</code> bit), we need to switch the master clock to HSE by writing 0xB4 into <code>CLK_SWR</code>. Finally, we wait until the clock source is stabilized and execute the clock switch by setting <code>SWEN</code> bit in <code>CLK_SWCR</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hse_enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Enable HSE crystal oscillator */</span></span><br><span class="line">    CLK_ECKR |= (<span class="number">1</span> &lt;&lt; CLK_ECKR_HSEEN);</span><br><span class="line">    <span class="keyword">while</span> (!(CLK_ECKR &amp; (<span class="number">1</span> &lt;&lt; CLK_ECKR_HSERDY)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch master clock to HSE */</span></span><br><span class="line">    CLK_SWR = <span class="number">0xB4</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(CLK_SWCR &amp; (<span class="number">1</span> &lt;&lt; CLK_SWCR_SWIF)));</span><br><span class="line">    CLK_SWCR |= (<span class="number">1</span> &lt;&lt; CLK_SWCR_SWEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="External-clock"><a href="#External-clock" class="headerlink" title="External clock"></a>External clock</h3><p>There is a nice trick when you need to sync two or more microcontrollers: instead of using a crystal you can supply an external clock to the oscillator input pin and leave the other pin floating. STM8 even has a dedicated mode for external clock source, which can be activated by enabling <code>EXTCLK</code> option bit.</p>
<p>The procedure for enabling external clock is identical to enabling HSE, except that we don’t write <code>HSEEN</code> bit, since we’re not driving an oscillator. In this case I used automatic clock switching mechanism: the only difference is that it allows the processor to run and execute instructions while the clock is being stabilized, although I’m still polling for <code>SWIF</code> since I want to stall the CPU until the clock switching is complete.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">external_clock_enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* set prescaler to 1 */</span></span><br><span class="line">    CLK_CKDIVR = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch master clock to HSE */</span></span><br><span class="line">    CLK_SWCR |= (<span class="number">1</span> &lt;&lt; CLK_SWCR_SWEN);</span><br><span class="line">    CLK_SWR = <span class="number">0xB4</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(CLK_SWCR &amp; (<span class="number">1</span> &lt;&lt; CLK_SWCR_SWIF)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After connecting the external clock source to OSCIN (PA1), we need to enable <code>EXTCLK</code> option bit by writing 0x08 into <code>OPT4</code> (option bytes will be discussed later on). Finally, we call <code>external_clock_enable()</code> and wait until the CPU switches clocks. We can ensure that clock switching is successful by enabling clock output and probing CLK_CCO pin.</p>
<p>The external clock source has to be a square wave with 50% duty cycle. According to the documentation, sine and triangle waveforms can be used as clock sources as well. The datasheet also claims that minimum CPU frequency is 0 Hz.</p>
<p>So, presumably, it’s possible to clock the CPU from a sinusoidal signal with frequency all the way down to DC. Ugh.. the temptation is irresistible. I don’t have a signal generator. <em>But I do have mains AC.</em></p>
<img src="/blog/bare-metal-programming-stm8-part2/50hz_clk.jpg" alt="What could possibly go wrong?" title="What could possibly go wrong?">

<p>Surprisingly, it worked. In case you’re wondering, the chip was able to survive 230V applied to it due to the fact that every pin on STM8 (except for ‘true open-drain’ pins) has protection diodes to Vcc and ground. These diodes will clamp any excessive voltages and prevent the part from releasing the magic smoke. Having a large value series resistor limits the current flowing through these diodes. The documentation doesn’t specify maximum current for clamping diodes, but it’s usually a good idea to keep it below 1mA. Keep in mind that when the diodes conduct the current has to return <em>somewhere</em> - in this case it’s the lithium battery. Did I mention that it’s not a particularly good idea?</p>
<h3 id="A-less-lethal-approach"><a href="#A-less-lethal-approach" class="headerlink" title="A less lethal approach"></a>A less lethal approach</h3><p>Although clocking the MCU directly from mains was kind of fun, I felt rather uncomfortable working when the microcontroller is live. Since I still wanted to find out how useful a mains-clocked processor is, I decided to make things a bit less hazardous by adding some opto-isolation.</p>
<p>I discovered that the clock input circuitry does not like low frequency signals with slow edges. Feeding the output of the opto-isolator directly into the microcontroller results in random glitches on the clock output due to false triggering, and occasionally the CPU just locks up. Applying mains directly worked better since the slew rate was higher in that case. The datasheet hints that HSE has to be above 1 MHz for external crystal, but doesn’t specify the lower limit for external user clock. I’m pretty sure we can get stable operation if we improve transition speed. For this purpose we’ll need to use a Schmitt trigger, which is basically a comparator with hysteresis, to convert the output of the optocoupler into a nice and clean square wave.</p>
<p>There are dedicated Schmitt trigger ICs and even opto-isolators with Schmitt trigger outputs - non of these do I have at hand. One can implement a Schmitt trigger using an op-amp, but if you want to save a few resistors you can use a good old 555 timer. The 555 has two comparators configured to fire off when voltage on their inputs reaches 1&#x2F;3 and 2&#x2F;3 Vcc respectively, which is just about right to set the hysteresis. Comparator inputs are pins 2 (Trigger) and 6 (Threshold). Below is the resulting schematic.</p>
<img src="/blog/bare-metal-programming-stm8-part2/schematic.jpg" alt="""" title="""">

<p>R1 is limiting the current flowing through the LED inside the optocoupler and D1 guarantees that reverse breakdown voltage of the LED would not be exceeded during the negative half cycle of the sine wave. Resistor values depend on the optocoupler being used. In my case I used LTV-817 (Vf &#x3D; 1.2V) and R1 will limit the peak current to Ipeak &#x3D; (325 - 1.2) &#x2F; 180000 &#x3D; 1.8mA. Since the threshold is fixed, I had to adjust R2 to get as close to 50% duty cycle as possible, which is why it’s value ended up being higher than it should be.</p>
<p>The only timer that I had was NE555 - it’s quite a slow chip not rated for 3.3V operation. A CMOS timer like LMC555 would be a much better choice. That being said, the resulting waveform is still acceptable.</p>
<img src="/blog/bare-metal-programming-stm8-part2/555_schmitt_trigger.png" alt="Schmitt Trigger" title="Schmitt Trigger">

<p>The duty cycle isn’t precisely 50% and the edges are a bit jagged and jittery, but still good enough for the processor to latch onto.</p>
<img src="/blog/bare-metal-programming-stm8-part2/555_edge.png" alt="""" title="""">

<p>After connecting the output of the Schmitt trigger to OSCIN, I ensured that I was getting a stable 50 Hz output on CLK_CCO pin and tried bringing up various peripherals. Below is the sped up footage of one of my experiments.</p>
<img src="/blog/bare-metal-programming-stm8-part2/spi_50hz.gif" alt="That took about 3 minutes.." title="That took about 3 minutes..">

<p>Well, that was the slowest SPI communication I’ve ever seen. Nevertheless, it was nice to know that the processor is still usable at such low clock frequencies.</p>
<h2 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h2><p>EEPROM is a small area of memory that can be used for storing things like configuration, calibration data, etc. On STM8S003 EEPROM starts at address 0x4000 and ends at 0x407F, which results in stunning 128 bytes of data. Let’s define some macros first. We’ll use the first macro for memory access, just like we did with register definitions in <a href="/blog/bare-metal-programming-stm8/#It%E2%80%99s-all-just-memory">part 1</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MEM_(mem_addr)         (*(volatile uint8_t *)(mem_addr))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EEPROM_START_ADDR       0x4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EEPROM_END_ADDR         0x407F</span></span><br></pre></td></tr></table></figure>

<p>By default, EEPROM is write protected and a specific sequence is required in order to unlock it: two hardware keys have to be written into <code>FLASH_DUKR</code> register. The first time I tried programming EEPROM it didn’t work. The reason was me ignoring the following statement in the reference manual: <em>“before starting programming, the application must verify that the DATA area is not write protected”</em>. I interpreted it as “you shouldn’t write into write-protected areas” while the real meaning was “it takes some time to unlock EEPROM”.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_write</span><span class="params">(<span class="keyword">uint16_t</span> addr, <span class="keyword">uint8_t</span> *buf, <span class="keyword">uint16_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* unlock EEPROM */</span></span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY1;</span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data from buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i = <span class="number">0</span>; i &lt; len; i++, addr++) &#123;</span><br><span class="line">        _MEM_(addr) = buf[i];</span><br><span class="line">        <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_EOP)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock EEPROM */</span></span><br><span class="line">    FLASH_IAPSR &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that on low density STM8S microcontrollers the CPU is stalled during EEPROM write operation, therefore it is not necessary to poll for <code>EOP</code> flag.</p>
<p>Reading EEPROM is achieved the same way you read any other memory:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_read</span><span class="params">(<span class="keyword">uint16_t</span> addr, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* read EEPROM data into buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++, addr++)</span><br><span class="line">        buf[i] = _MEM_(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interestingly, <a target="_blank" rel="noopener" href="http://www.st.com/resource/en/programming_manual/cd00191343.pdf">flash programming manual</a> states that on low density devices, EEPROM is comprised of additional 640 bytes of memory located in the same memory array with flash. In other words, it seems like there are 10 pages of flash memory reserved for EEPROM. Also, the manual gives the exact value (it doesn’t say <em>up to</em> 640 bytes), which contradicts with the datasheet.</p>
<p>Let’s try shifting <code>EEPROM_END_ADDR</code> to 0x4280 and filling the whole range with dummy bytes:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY1;</span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> addr = EEPROM_START_ADDR; addr &lt; EEPROM_END_ADDR; addr++)</span><br><span class="line">        _MEM_(addr) = <span class="number">0xAA</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can dump EEPROM and check if it was written. I deliberately specified <code>stm8s103f3</code> to read more memory than our part has.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stm8flash -c stlinkv2 -p stm8s103f3 -s eeprom -r dump.bin</span><br></pre></td></tr></table></figure>

<p>Yeap, it worked on every processor that I tried. Although I would rather prefer having a bit more flash memory, it’s still good to know that STM8S003 has some extra EEPROM.</p>
<h2 id="Option-bytes"><a href="#Option-bytes" class="headerlink" title="Option bytes"></a>Option bytes</h2><p>Option bytes are located in the EEPROM and allow configuring device hardware features such as readout protection and alternate function mapping. Each option byte, except for read-out protection, has to be stored in a normal form (OPTx) and complementary form (NOPTx). The procedure for writing option bytes is the same as for writing EEPROM, except for the unlcok sequence: <code>OPT</code> bit has to be set in <code>FLASH_CR2</code> and <code>FLASH_NCR2</code> registers.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">opt_write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* new value for OPT5 (default is 0x00) */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> opt5 = <span class="number">0xb4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock EEPROM */</span></span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY1;</span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock option bytes */</span></span><br><span class="line">    FLASH_CR2 |= (<span class="number">1</span> &lt;&lt; FLASH_CR2_OPT);</span><br><span class="line">    FLASH_NCR2 &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_NCR2_NOPT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write option byte and it&#x27;s complement */</span></span><br><span class="line">    OPT5 = opt5;</span><br><span class="line">    NOPT5 = ~opt5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until programming is finished */</span></span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_EOP)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock EEPROM */</span></span><br><span class="line">    FLASH_IAPSR &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you mess things up, you can reset the option bytes via SWIM:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -ne <span class="string">&#x27;\x00\x00\xff\x00\xff\x00\xff\x00\xff\x00\xff&#x27;</span> &gt; opt.bin</span><br><span class="line">$ stm8flash -c stlinkv2 -p stm8s003f3 -s opt -w opt.bin</span><br></pre></td></tr></table></figure>

<p>Interestingly, if we read the memory a bit further, we find a section which contains the following data:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x480B: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x4823: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x483B: 00 00 00 00 00 0c f3 12 ed 12 ed cd 32 77 88 49 b6 01 fe 20 df 03 fc 01</span><br><span class="line">0x4853: fe 00 00 00 00 00 00 00 00 00 00 00 00 57 00 1f 5b 00 00 1e 00 3f 07 47</span><br><span class="line">0x486B: 36 31 34 32 31 33 1f 00 00 1f 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>20 bytes at address 0x4840 are written with their complement values just like the option bytes. This whole block is write protected and differs slightly from one processor to another - unique ID perhaps?</p>
<h2 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h2><p>One thing that I like the most about STM8 is flash access.</p>
<p>The two most common types of flash memory are NAND and NOR flash. Flash is physically divided into blocks, which may be further divided into sectors. The entire memory is linear and can be read or written in a random access fashion, however both NAND and NOR flash share the same disadvantage: you can flip a 1 into a 0 but not vice-versa. The only way to flip a 0 back to 1 is to erase the whole block. If you need to overwrite a few bytes in flash memory you have to buffer the whole page into RAM, modify the buffer, erase flash page and write the buffer back into flash memory - the whole process is rather time-consuming.</p>
<p>With STM8 this is not the case: the whole memory can be accessed at byte level. You can write any byte inside any page and erase it by simply writing 0x00 at that address. Essentially, you can treat flash memory as a large EEPROM.</p>
<p>Removing write protection is almost identical to unprotecting EEPROM.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flash_write</span><span class="params">(<span class="keyword">uint16_t</span> addr, <span class="keyword">uint8_t</span> *buf, <span class="keyword">uint16_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* unlock flash */</span></span><br><span class="line">    FLASH_PUKR = FLASH_PUKR_KEY1;</span><br><span class="line">    FLASH_PUKR = FLASH_PUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_PUL)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data from buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i = <span class="number">0</span>; i &lt; len; i++, addr++) &#123;</span><br><span class="line">        _MEM_(addr) = buf[i];</span><br><span class="line">        <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_EOP)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock flash */</span></span><br><span class="line">    FLASH_IAPSR &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_IAPSR_PUL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Just like with EEPROM, we can dump the entire flash memory:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stm8flash -c stlinkv2 -p stm8s003f3 -s flash -r dump.bin</span><br></pre></td></tr></table></figure>

<p>SDCC has various attributes like <code>__xdata</code> and <code>__eeprom</code> for placing things in specific memory locations. Unfortunately, none of them are implemented for STM8 yet. We can partially work around this limitation by using <code>__at</code> attribute:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Use last 64 bytes of flash for user data */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID_ADDR                 (0x8000 + 0x1FC0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_DATA_ADDR          (ID_ADDR + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tell compiler where the variables are located */</span></span><br><span class="line">__at(USER_DATA_ADDR) <span class="keyword">uint8_t</span> data[<span class="number">8</span>];</span><br><span class="line">__at(ID_ADDR) <span class="keyword">const</span> <span class="keyword">uint8_t</span> id = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>Let’s take a closer look at the above example: first we define two addresses in flash memory. Remember that program memory starts at 0x8000, so we add this value to get the address we want. Next we declare <code>data</code> array with attribute <code>__at(USER_DATA_ADDR)</code> - this tells the compiler where to look when the variable is being accessed. For example, a read operation on <code>data[2]</code> will return the value at address 0x9FC3, which is the same as calling <code>_MEM_(0x9FC3)</code>. Same goes for write operation: if flash is unlocked, then writing <code>data[2]</code> will store the value at the appropriate address in flash memory. If flash unlock sequence was not executed before performing a write, then <code>WR_PG_DIS</code> bit will be set in <code>FLASH_IAPSR</code> register to indicate an attempt to modify write-protected page.</p>
<p>The second variable <code>id</code> is declared as <code>const</code> - this will actually produce a binary with the value placed at specified memory address. Declaring a variable as constant means that compiler will not allow us to perform explicit write operations, unless we write directly at the specified address (which kind of defeats the purpose of <code>const</code> qualifier). Unfortunately, this approach will not work for EEPROM - SDCC will simply produce a larger binary image.</p>
<hr>
<p>That’s it for now. In the next part we’re going to take a look at some of the features essential for real-world applications and discuss questions of reliability and performance. As always, code is available on <a target="_blank" rel="noopener" href="https://github.com/lujji/stm8-bare-min">github</a>. Since previous article the repository evolved into a small peripheral library with dedicated examples directory.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/" data-id="cle467sry0000axcxau9ncaw9" class="article-share-link">Share</a>
      
        <a href="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/bare-metal/" rel="tag">bare-metal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/sdcc/" rel="tag">sdcc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stm8/" rel="tag">stm8</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/executing-code-from-ram-on-stm8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer Posts</strong>
      <div class="article-nav-title">
        
          Executing code from RAM on STM8
        
      </div>
    </a>
  
  
    <a href="/blog/bare-metal-programming-stm8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older Posts</strong>
      <div class="article-nav-title">Bare metal programming: STM8</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/power-analysis-with-ds1000z/">Power analysis with Rigol DS1000Z</a>
          </li>
        
          <li>
            <a href="/blog/serial-bootloader-for-stm8/">Serial bootloader for STM8</a>
          </li>
        
          <li>
            <a href="/blog/mixing-c-and-assembly-on-stm8/">Mixing C and assembly on STM8</a>
          </li>
        
          <li>
            <a href="/blog/executing-code-from-ram-on-stm8/">Executing code from RAM on STM8</a>
          </li>
        
          <li>
            <a href="/blog/bare-metal-programming-stm8-part2/">Bare metal programming: STM8 (Part 2)</a>
          </li>
        
          <li>
            <a href="/blog/bare-metal-programming-stm8/">Bare metal programming: STM8</a>
          </li>
        
          <li>
            <a href="/blog/installing-blackmagic-via-stlink-bootloader/">Installing Black Magic via ST-Link bootloader</a>
          </li>
        
          <li>
            <a href="/blog/esp-httpd/">HTTP server with WebSockets on ESP8266</a>
          </li>
        
          <li>
            <a href="/blog/reverse-engineering-stlink-firmware-part2/">Reverse-engineering ST-Link firmware - Part 2</a>
          </li>
        
          <li>
            <a href="/blog/reverse-engineering-stlink-firmware/">Reverse-engineering ST-Link firmware</a>
          </li>
        
          <li>
            <a href="/blog/stlink-clone-trace/">Adding Trace support to ST-Link clones</a>
          </li>
        
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 lujji<br>      
      lujji at protonmail com
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'lujji';
  
  var disqus_url = 'http://lujji.github.io/blog/bare-metal-programming-stm8-part2/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>


  </div>
</body>
</html>