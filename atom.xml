<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lujji</title>
  <icon>https://www.gravatar.com/avatar/2552f9757a86e41b04f4b232e9b24152</icon>
  <subtitle>embedded stuff</subtitle>
  <link href="http://lujji.github.io/blog/atom.xml" rel="self"/>
  
  <link href="http://lujji.github.io/blog/"/>
  <updated>2023-02-14T10:54:42.242Z</updated>
  <id>http://lujji.github.io/blog/</id>
  
  <author>
    <name>lujji</name>
    <email>lujji at protonmail com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Power analysis with Rigol DS1000Z</title>
    <link href="http://lujji.github.io/blog/power-analysis-with-ds1000z/"/>
    <id>http://lujji.github.io/blog/power-analysis-with-ds1000z/</id>
    <published>2023-02-14T10:54:42.000Z</published>
    <updated>2023-02-14T10:54:42.242Z</updated>
    
    <content type="html"><![CDATA[<p>Recently, I had to analyze the power profile of a microcontroller at a specific point in time. This article will cover the required steps to perform such measurements with Rigol DS1054Z&#x2F;1104Z oscilloscope.</p><span id="more"></span><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents:"></a>Contents:</h2><ul><li><a href="#Python-interface">Python interface</a></li><li><a href="#Collecting-waveforms">Collecting waveforms</a></li><li><a href="#Processing-data">Processing data</a></li><li><a href="#Aligning-traces">Aligning traces</a></li><li><a href="#Conclusion">Conclusion</a></li></ul><h2 id="Python-interface"><a href="#Python-interface" class="headerlink" title="Python interface"></a>Python interface</h2><p>You can connect to the oscilloscope via USB or LAN&#x2F;LXI. Since it’s only USB2.0, you might think that LAN would be much faster, however this is not the case - download speed over LAN is painfully slow.</p><p>In order to interact with the scope from python first we need to install <code>pyvisa-py</code> and <code>pyusb</code> modules via pip. Now we can send SCPI commands that are described in <a href="https://www.batronix.com/files/Rigol/Oszilloskope/_DS&MSO1000Z/MSO_DS1000Z_ProgrammingGuide_EN.pdf">DS1000Z Programming Guide</a>.</p><p>This is where things get ugly. Simple queries worked fine, but as soon as I tried to read the waveform I encountered either a timeout or the following error:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">usbtmc.py:115: UserWarning: Unexpected MsgID format. Consider updating the device&#x27;s firmware.</span><br><span class="line">See https://github.com/pyvisa/pyvisa-py/issues/20</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  File &quot;/usr/lib/python3.11/site-packages/pyvisa/resources/messagebased.py&quot;, line 486, in read</span><br><span class="line">    message = self._read_raw().decode(enco)</span><br><span class="line">              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode byte 0xff in position 0: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>At the moment of writing the article I was using python 3.11 with pyvisa-py 0.6.2. Firmware was already up to date and increasing the timeout didn’t help at all. It seems like every time a try any python wrapper around libusb it simply doesn’t work..</p><p>After half an hour of debugging I found that setting <code>chunk_size</code> to 32 produces stable(-ish) results on both of my machines. If that doesn’t help, you might want to try setting <code>RECV_CHUNK</code> to 32 and <code>max_padding</code> to 0 in <code>pyvisa_py/protocols/usbtmc.py</code></p><h2 id="Collecting-waveforms"><a href="#Collecting-waveforms" class="headerlink" title="Collecting waveforms"></a>Collecting waveforms</h2><p>Be default <code>:WAV:DATA?</code> command will return the on-screen memory, which is limited to 1200 points. Since we need slightly more than that, we’ll have to perform a ‘deep-memory’ read. We can read only 250k points each time, so the memory has to be read out in chunks. After some trial and error I found out that higher values like 500k work as well, although stability degrades. By ‘stability’ I mean the amount of retries required to read each chunk successfully - even 250k read might take 1-2 attempts to complete successfully.</p><p>The following script assumes that we trigger on CH2 and capture CH1 waveform. For each trace we’re arming the scope, waiting for the acquisition to complete, performing deep-memory read and dumping the results into csv file. Things like memory depth and trigger settings should be configured on the scope manually.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pyvisa <span class="keyword">import</span> ResourceManager</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"></span><br><span class="line">rm = ResourceManager(<span class="string">&#x27;@py&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> rm.list_resources():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;USB&#x27;</span> <span class="keyword">in</span> r:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Connecting over USB&#x27;</span>)</span><br><span class="line">        rig = rm.open_resource(r)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Scope not found&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">rig.timeout = <span class="number">1500</span></span><br><span class="line">rig.chunk_size = <span class="number">32</span></span><br><span class="line">max_points = <span class="number">250_000</span> <span class="comment"># lower value = more stable</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;device:&#x27;</span>, rig.query(<span class="string">&#x27;*IDN?&#x27;</span>))</span><br><span class="line">rig.write(<span class="string">&#x27;:WAV:MODE RAW&#x27;</span>)</span><br><span class="line">rig.write(<span class="string">&#x27;:WAV:FORM BYTE&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mem = <span class="built_in">int</span>(rig.query(<span class="string">&#x27;:ACQ:MDEP?&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> max_points &gt; mem: max_points = mem</span><br><span class="line">f = <span class="built_in">open</span>(time.strftime(<span class="string">&#x27;%b-%d-%Y_%H-%M-%S&#x27;</span>, time.localtime()) + <span class="string">&#x27;_trace.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> trace <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># single capture</span></span><br><span class="line">    rig.write(<span class="string">&#x27;:SING&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.3</span>) <span class="comment"># STOP-&gt;WAIT transition takes a while</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting for trigger..&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;STOP&#x27;</span> <span class="keyword">in</span> rig.query(<span class="string">&#x27;:TRIG:STAT?&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># deep memory read</span></span><br><span class="line">    buf = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ceil(mem / max_points)):</span><br><span class="line">        start = i * max_points</span><br><span class="line">        stop = start + max_points</span><br><span class="line">        stop = mem <span class="keyword">if</span> stop &gt; mem <span class="keyword">else</span> stop</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        rig.write(<span class="string">f&#x27;:WAV:STAR <span class="subst">&#123;start + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">        rig.write(<span class="string">f&#x27;:WAV:STOP <span class="subst">&#123;stop&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> retries <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                tmp = rig.query_binary_values(<span class="string">&#x27;:WAV:DATA? CH1&#x27;</span>, datatype=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(tmp) != stop - start:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&#x27;got <span class="subst">&#123;<span class="built_in">len</span>(tmp)&#125;</span>/<span class="subst">&#123;stop - start&#125;</span> bytes - retrying&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                buf += tmp</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;retrying&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    f.write(<span class="string">&#x27;,&#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> buf]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line">rig.close()</span><br></pre></td></tr></table></figure><h2 id="Aligning-traces"><a href="#Aligning-traces" class="headerlink" title="Aligning traces"></a>Aligning traces</h2><p>Since we’re triggering on a different channel and our event of interest occurs some time after the trigger, our traces most likely will have some misalignment due to various reasons like clock jitter, which we’ll need to learn how to deal with.</p><p>Let’s say we have two signals <code>a</code> and <code>b</code> offset by phase:</p><img src="/blog/power-analysis-with-ds1000z/xcorr_example_0.png" alt="""" title=""""><p>We can ‘align’ them by using <a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>. Applying some filtering prior to that is also a good idea, but we’ll skip this step for now. Cross-correlation doesn’t play well with signals that have some DC bias and can produce false peaks, so we remove that first. Next we find the largest peak - this is the point where our signals align.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> shift</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove DC offset</span></span><br><span class="line">a -= np.mean(a)</span><br><span class="line">b -= np.mean(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cross-correlation</span></span><br><span class="line">cor = signal.correlate(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find maximum</span></span><br><span class="line">px, py = signal.find_peaks(cor, height=<span class="number">0</span>)</span><br><span class="line">peak_x = px[np.argmax(py[<span class="string">&#x27;peak_heights&#x27;</span>])]</span><br></pre></td></tr></table></figure><img src="/blog/power-analysis-with-ds1000z/xcorr_example_1.png" alt="Cross-correlation" title="Cross-correlation"><p>Cross-correlation produces a sequence of length <code>2n - 1</code> symmetrical around a single point with ‘zero’ being in the middle of the x-axis. Our phase shift is the x-coordinate of the maximum relative to ‘zero’. Knowing the offset, all we have to do is shift one of the signals. Obviously we loose some data after performing the shift - you can throw these points away from both traces or fill them with some fixed value instead (in this case - median).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># align traces</span></span><br><span class="line">offset = <span class="built_in">len</span>(a) - peak_x - <span class="number">1</span></span><br><span class="line">b = shift(b, -offset, cval=np.median(b))</span><br></pre></td></tr></table></figure><img src="/blog/power-analysis-with-ds1000z/xcorr_example_2.png" alt="Aligned traces" title="Aligned traces"><h2 id="Processing-data"><a href="#Processing-data" class="headerlink" title="Processing data"></a>Processing data</h2><p>Now we can process the captured traces. Of course we can load everything into memory, but in case we might need gigabytes worth of traces (good luck capturing those with this scope), we’re going to read the capture file line-by-line, align each trace with the reference trace and apply a simple moving average.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> shift</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;traces.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># process the first trace and use it as reference</span></span><br><span class="line">    a = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> f.readline().split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line">    a -= np.mean(a)</span><br><span class="line">    averaged_trace = a[:]</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    l = f.readline()</span><br><span class="line">    <span class="keyword">while</span> l:</span><br><span class="line">        b = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> l.split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line">        b -= np.mean(b)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># find the offset using cross-correlation</span></span><br><span class="line">        cor = signal.correlate(a, b)</span><br><span class="line">        px, py = signal.find_peaks(cor, height=<span class="number">0</span>)</span><br><span class="line">        peak_x = px[np.argmax(py[<span class="string">&#x27;peak_heights&#x27;</span>])]</span><br><span class="line">        offset = <span class="built_in">len</span>(a) - peak_x - <span class="number">1</span> <span class="comment"># a -&gt; b offset</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># align the trace</span></span><br><span class="line">        b = shift(b, -offset, cval=np.median(b))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># moving average</span></span><br><span class="line">        averaged_trace = [(b[i] + n*averaged_trace[i])/(n + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b))]</span><br><span class="line"></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        l = f.readline()</span><br><span class="line"></span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.plot(a)</span><br><span class="line">plt.plot(averaged_trace)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Even though DS1054Z is definitely not the best tool for this job, it can still get the job done, especially with a bit of patience. Below is the example of one of the sets of traces that I captured. As usual, code is on <a href="https://github.com/lujji/ds1000z-scripts">github</a>.</p><img src="/blog/power-analysis-with-ds1000z/result.png" alt="""" title="""">]]></content>
    
    
    <summary type="html">&lt;p&gt;Recently, I had to analyze the power profile of a microcontroller at a specific point in time. This article will cover the required steps to perform such measurements with Rigol DS1054Z&amp;#x2F;1104Z oscilloscope.&lt;/p&gt;</summary>
    
    
    
    
    <category term="rigol" scheme="http://lujji.github.io/blog/tags/rigol/"/>
    
    <category term="digital-signal-processing" scheme="http://lujji.github.io/blog/tags/digital-signal-processing/"/>
    
    <category term="side-channel-attack" scheme="http://lujji.github.io/blog/tags/side-channel-attack/"/>
    
  </entry>
  
  <entry>
    <title>Serial bootloader for STM8</title>
    <link href="http://lujji.github.io/blog/serial-bootloader-for-stm8/"/>
    <id>http://lujji.github.io/blog/serial-bootloader-for-stm8/</id>
    <published>2017-08-07T21:00:00.000Z</published>
    <updated>2017-08-08T17:19:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>This article will cover developing a serial bootloader for STM8S microcontrollers.</p><span id="more"></span><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents:"></a>Contents:</h2><ul><li><a href="#Entry-condition">Entry condition</a></li><li><a href="#Serial-protocol">Serial protocol</a></li><li><a href="#Flash-block-programming">Flash block programming</a></li><li><a href="#Interrupt-vector-table-relocation">Interrupt vector table relocation</a></li><li><a href="#Squeezing-the-last-bytes">Squeezing the last bytes</a></li><li><a href="#Benchmarking">Benchmarking</a></li></ul><h2 id="Entry-condition"><a href="#Entry-condition" class="headerlink" title="Entry condition"></a>Entry condition</h2><p>Bootloader code gets executed first, so we need some mechanism to decide whether we want to update the firmware or execute main application. These are the most common approaches:</p><ul><li><strong>Configuration byte</strong>: an indicator flag, which is written by the application when firmware update is requested and cleared by the bootloader once firmware update is performed</li><li><strong>Timeout</strong>: the bootloader waits for some external event during start-up. When specified timeout is reached, main application is executed</li><li><strong>External jumper</strong>: external switch or jumper which selects between bootloader and application mode</li></ul><p>We’ll go with the third option, since it’s the easiest one to implement in my opinion. We also need to define where the main application will reside. Let’s be generous at first and dedicate 1k of flash to the bootloader, although we’ll cut the size down eventually. Since flash memory is mapped to address 0x8000, the destination address for the application will be 0x8400.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BOOT_PIN_CR1 = <span class="number">1</span> &lt;&lt; BOOT_PIN;</span><br><span class="line">    <span class="keyword">if</span> (!(BOOT_PIN_IDR &amp; (<span class="number">1</span> &lt;&lt; BOOT_PIN))) &#123;</span><br><span class="line">        <span class="comment">/* execute bootloader */</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* jump to application */</span></span><br><span class="line">        BOOT_PIN_CR1 = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">__asm__</span>(<span class="string">&quot;jp 0x8400&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Our main application has to be compiled with <code>--code-loc 0x8400</code> option, which instructs SDCC where code should be placed.</p><h2 id="Serial-protocol"><a href="#Serial-protocol" class="headerlink" title="Serial protocol"></a>Serial protocol</h2><p>The firmware update will be initiated by sending the bootloader a preamble of 4 bytes. Preamble detection will look like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bootloader_enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> rx;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        rx = uart_read();</span><br><span class="line">        <span class="keyword">if</span> (rx != <span class="number">0xDE</span>) <span class="keyword">continue</span>;</span><br><span class="line">        rx = uart_read();</span><br><span class="line">        <span class="keyword">if</span> (rx != <span class="number">0xAD</span>) <span class="keyword">continue</span>;</span><br><span class="line">        rx = uart_read();</span><br><span class="line">        <span class="keyword">if</span> (rx != <span class="number">0xBE</span>) <span class="keyword">continue</span>;</span><br><span class="line">        rx = uart_read();</span><br><span class="line">        <span class="keyword">if</span> (rx != <span class="number">0xEF</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Once preamble is detected, the bootloader reads next 3 bytes: number of data blocks to be sent and two CRC-8 bytes which are duplicated to avoid transmission errors.</p><p>After that, we follow a simple request-response protocol: the host waits for an acknowledgment and then sends a fixed size chunk of data. Bootloader receives the chunk, writes flash memory block and sends ACK again to indicate that it’s ready for another packet. When all data chunks have been sent, the bootloader verifies CRC and sends another ACK if CRC matches or NACK if it doesn’t match. If the last chunk is smaller than defined block size, the remaining bytes are padded with 0xFF by the host.</p><img src="/blog/serial-bootloader-for-stm8/serial_protocol.png" alt="Communication protocol" title="Communication protocol"><p>Main bootloader code will look like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE      64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOT_ADDR       0x8400</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bootloader_exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> addr = BOOT_ADDR;</span><br><span class="line">    <span class="keyword">uint8_t</span> chunks, crc_rx;</span><br><span class="line"></span><br><span class="line">    bootloader_enter();</span><br><span class="line">    chunks = uart_read();</span><br><span class="line">    crc_rx = uart_read();</span><br><span class="line">    <span class="keyword">if</span> (crc_rx != uart_read())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get main firmware */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0</span>; i &lt; chunks; i++) &#123;</span><br><span class="line">        serial_read_block(rx_buffer);</span><br><span class="line">        flash_write_block(addr, rx_buffer);</span><br><span class="line">        addr += BLOCK_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* verify CRC */</span></span><br><span class="line">    <span class="keyword">if</span> (CRC != crc_rx) &#123;</span><br><span class="line">        serial_send_nack();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serial_send_ack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The microcontroller that I’m using is a low-density STM8S003F3 so the block size will be equal to 64 bytes. For medium and high density devices the block size is 128 bytes.</p><p>In one of the previous <a href="https://lujji.github.io/blog/bare-metal-programming-stm8-part2/#Flash">articles</a> I mentioned that we can write flash one byte at a time, however on the hardware level one word (4 bytes) will be overwritten. Flash controller simplifies it for us by reading, modifying, erasing and writing a word each time a byte write is requested. We’ll try to speed things up a little by writing 4 bytes at a time, which can be achieved by enabling <code>WPRG</code> bit in Flash Control Register 2. This bit is reset after programming is done so it has to be manually re-enabled before each write operation.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flash_write_block</span><span class="params">(<span class="keyword">uint16_t</span> addr, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *end = buf + BLOCK_SIZE;</span><br><span class="line">    <span class="keyword">uint8_t</span> *mem = (<span class="keyword">uint8_t</span> *) addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock flash */</span></span><br><span class="line">    FLASH_PUKR = FLASH_PUKR_KEY1;</span><br><span class="line">    FLASH_PUKR = FLASH_PUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_PUL)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0</span>; i &lt; BLOCK_SIZE; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">/* enable word programming */</span></span><br><span class="line">        FLASH_CR2 = <span class="number">1</span> &lt;&lt; FLASH_CR2_WPRG;</span><br><span class="line">        FLASH_NCR2 = ~(<span class="number">1</span> &lt;&lt; FLASH_NCR2_NWPRG);</span><br><span class="line">        *mem++ = *buf++;</span><br><span class="line">        *mem++ = *buf++;</span><br><span class="line">        *mem++ = *buf++;</span><br><span class="line">        *mem++ = *buf++;</span><br><span class="line">        <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_EOP)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock flash */</span></span><br><span class="line">    FLASH_IAPSR &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_IAPSR_PUL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s one problem with this code though - it’s incredibly slow. I was hoping we could get away with word programming, but clearly this is not the case.</p><h2 id="Flash-block-programming"><a href="#Flash-block-programming" class="headerlink" title="Flash block programming"></a>Flash block programming</h2><p>The most efficient way of programming flash is the block programming method. The only downside is that the processor will no longer be able to fetch instructions from flash during programming, so we’ll have to execute our code from RAM. I’ve already covered <a href="https://lujji.github.io/blog/executing-code-from-ram-on-stm8/">executing code from RAM</a> before, so I won’t go into much detail here.</p><p>Let’s re-implement our flash programming routine:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> codeseg RAM_SEG</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ram_flash_write_block</span><span class="params">(<span class="keyword">uint16_t</span> addr, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *end = buf + BLOCK_SIZE;</span><br><span class="line">    <span class="keyword">uint8_t</span> *mem = (<span class="keyword">uint8_t</span> *)(addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock flash */</span></span><br><span class="line">    FLASH_PUKR = FLASH_PUKR_KEY1;</span><br><span class="line">    FLASH_PUKR = FLASH_PUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_PUL)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable block programming */</span></span><br><span class="line">    FLASH_CR2 = <span class="number">1</span> &lt;&lt; FLASH_CR2_PRG;</span><br><span class="line">    FLASH_NCR2 = ~(<span class="number">1</span> &lt;&lt; FLASH_NCR2_NPRG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data from buffer */</span></span><br><span class="line">    <span class="keyword">while</span> (buf &lt; end)</span><br><span class="line">        *mem++ = *buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait for operation to complete */</span></span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_EOP)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock flash */</span></span><br><span class="line">    FLASH_IAPSR &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_IAPSR_PUL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We use ‘standard’ mode which erases the block automatically. Some inline assembly is required to retrieve code section length:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> RAM_SEG_LEN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_ram_section_length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">__asm__</span>(<span class="string">&quot;mov _RAM_SEG_LEN, #l_RAM_SEG&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This trick works because RAM function is small enough to fit into 255 bytes - otherwise we’d use a slightly different mechanism. Finally, we copy the subroutine into RAM:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> f_ram[<span class="number">128</span>];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*flash_write_block)</span><span class="params">(<span class="keyword">uint16_t</span> addr, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ram_cpy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> len = get_ram_section_length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        f_ram[i] = ((<span class="keyword">uint8_t</span> *) ram_flash_write_block)[i];</span><br><span class="line">    flash_write_block = (<span class="keyword">void</span> (*)(<span class="keyword">uint16_t</span>, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *)) &amp;f_ram;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Interrupt-vector-table-relocation"><a href="#Interrupt-vector-table-relocation" class="headerlink" title="Interrupt vector table relocation"></a>Interrupt vector table relocation</h2><p>An interrupt vector table (IVT) is a chunk of address space. Each entry in the interrupt table is called an ‘interrupt vector’, which points to the address of an interrupt service routine (ISR). When interrupt occurs, CPU registers are pushed on the stack, program counter gets set to the address of the corresponding interrupt vector and the first instruction at that address is fetched. There is a dedicated INT instruction which jumps to the interrupt service routine address. After the ISR finishes, IRET instruction must be executed in order to restore contents of the registers.</p><p>STM8 has 32 4-byte interrupt vectors starting at address 0x8000: RESET, TRAP, TLI and up to 29 user interrupts specific to each part. Immediately we start to see a problem: if the IVT is located at the beginning of the flash memory, which is where our bootloader resides, how is the main application going to handle interrupts? There are different ways to address this issue, but most of the time it boils down to something called ‘IVT relocation’. Essentially we are going to have 2 separate vector tables for the bootloader and main application. The IVT inside the bootloader will simply point to the corresponding vectors in the main application.</p><p>Let’s illustrate all of the above on a random interrupt handler:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tim4_isr</span><span class="params">()</span> __<span class="title">interrupt</span><span class="params">(TIM4_ISR)</span> __naked </span>&#123;</span><br><span class="line">    <span class="keyword">__asm__</span>(<span class="string">&quot;jp 0x8464&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The interrupt handler is declared with <code>__naked</code> attribute, which instructs SDCC to omit <code>reti</code> instruction at the end of the handler, thus saving some program space. We can do so without any consequences, since we’re jumping to another interrupt handler which will execute this instruction anyway.</p><p>I don’t like this approach, and here’s why. When interrupt occurs the CPU pushes registers on the stack, which takes 9 cycles. Then <code>int</code> instruction is executed (2 cycles) which jumps to our interrupt handler. Our interrupt handler performs a jump (2 cycles) to the application interrupt vector, which executes another <code>int</code> followed by the interrupt handler code (?? cycles) followed by <code>iret</code> (11 cycles). That’s an overhead of 26 CPU cycle minimum, where 4 cycles were introduced by our interrupt handler. We also waste about 3 bytes of flash memory per handler. As a result, we end up with vector table and interrupt handlers that pretty much do nothing but consume space and processor cycles.</p><p>There is another approach: we can simply overwrite the first two blocks of memory with the application’s IVT. If we do that, however, our main application will always be executed instead of the bootloader, since we’ve overwritten the reset interrupt. The solution is to skip the first two bytes, thus leaving the reset vector intact:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">2</span>; i &lt; <span class="number">2</span> * BLOCK_SIZE; i++) &#123;</span><br><span class="line">    *(<span class="keyword">uint8_t</span> *)(<span class="number">0x8000</span> + i) = ivt[i];</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_EOP)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The downside is that we can no longer use ST’s User Boot Code (UBC) feature, which translated into English means ‘write protection’. Having an unprotected bootloader implies that it can be overwritten by accident - that is a trade-off between performance and reliability.</p><p>With this approach, main application requires a few adjustments. By default, SDCC will strip any unused interrupt handlers, which is not what we want. The easiest way to force SDCC to populate the whole IVT is to declare an empty interrupt handler for the last ISR:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr29</span><span class="params">()</span> __<span class="title">interrupt</span><span class="params">(<span class="number">29</span>)</span> __naked </span>&#123; ; &#125;</span><br></pre></td></tr></table></figure><p>Finally, the size of the IVT must be subtracted from the application address, so if we compiled with <code>--code-loc 0x8400</code> option before, we’ll have to use 0x8380 instead.</p><h2 id="Squeezing-the-last-bytes"><a href="#Squeezing-the-last-bytes" class="headerlink" title="Squeezing the last bytes"></a>Squeezing the last bytes</h2><p>After a few optimizations the bootloader size was slightly below 700 bytes. That still wasn’t good enough for me, since I was aiming at less than 640 bytes (10 blocks). The obvious hot-spot was the IVT: if we relocate it by redirecting interrupt handlers we waste space and if we overwrite it by the bootloader we introduce some additional code, thus still wasting some space.</p><p>Ideally, I wanted to implement my own interrupt table, however, it seems that it’s hard-coded inside SDCC. After spending some time with the documentation and browsing through the mailing lists, I just ended up looking at the compiler’s source code. There is a function <code>createInterruptVect()</code> inside <code>SDCCglue.c</code> which is responsible for generating the interrupt vectors. As it turns out, it checks whether or not <code>main()</code> is implemented and then proceeds with the interrupt table generation. So the solution was pretty simple: rename <em>main</em> into <em>bootloader_main</em> and no interrupt vectors will be generated.</p><p>The initialization code is also omitted in this case, but that’s not a big deal - I simply copied the default initialization and added it to my interrupt table implementation:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.module INIT</span><br><span class="line"><span class="meta">.macro</span> <span class="keyword">jump </span><span class="keyword">addr</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">jp </span><span class="number">0x8400</span> + <span class="keyword">addr</span></span><br><span class="line"><span class="keyword"></span>    .ds <span class="number">1</span></span><br><span class="line"><span class="meta">.endm</span></span><br><span class="line"></span><br><span class="line">.area IVT</span><br><span class="line">int init <span class="comment">; reset</span></span><br><span class="line"><span class="keyword">jump </span><span class="number">0x4</span> <span class="comment">; trap</span></span><br><span class="line"><span class="keyword">jump </span><span class="number">0x8</span> <span class="comment">; int0</span></span><br><span class="line"><span class="keyword">jump </span><span class="number">0xc</span> <span class="comment">; int1</span></span><br><span class="line"><span class="comment">;  ...   ; int2..28</span></span><br><span class="line"><span class="keyword">jump </span><span class="number">0x7c</span> <span class="comment">; int29</span></span><br><span class="line"></span><br><span class="line">.area GSINIT</span><br><span class="line"><span class="symbol">init:</span></span><br><span class="line">    ldw x, <span class="comment">#l_DATA</span></span><br><span class="line">    <span class="keyword">jreq </span>   <span class="number">00002</span>$</span><br><span class="line"><span class="number">00001</span>$:</span><br><span class="line">    clr (s_DATA - <span class="number">1</span>, x)</span><br><span class="line">    decw x</span><br><span class="line">    <span class="keyword">jrne </span>   <span class="number">00001</span>$</span><br><span class="line"><span class="number">00002</span>$:</span><br><span class="line">    ldw x, <span class="comment">#l_INITIALIZER</span></span><br><span class="line">    <span class="keyword">jreq </span>   <span class="number">00004</span>$</span><br><span class="line"><span class="number">00003</span>$:</span><br><span class="line">    ld  a, (s_INITIALIZER - <span class="number">1</span>, x)</span><br><span class="line">    ld  (s_INITIALIZED - <span class="number">1</span>, x), a</span><br><span class="line">    decw    x</span><br><span class="line">    <span class="keyword">jrne </span>   <span class="number">00003</span>$</span><br><span class="line"><span class="number">00004</span>$:</span><br><span class="line">    <span class="keyword">jp </span> _bootloader_main</span><br></pre></td></tr></table></figure><p>I created a macro for relocating interrupt vectors, so that it would be easier to specify boot address if it needs to be changed. In this case <code>jp</code> instruction is used instead of <code>int</code> so the overhead is just 1 CPU cycle (there’s also pipeline stall, but that’s a whole different topic). One padding byte has to be added due to <code>jp</code> using a 16-bit address instead of 24-bit.</p><p>Now we can assemble the code with the <code>-g</code> option, which tells the assembler to treat all undefined symbols as external - they will be resolved by the linker afterwards.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdasstm8 -<span class="built_in">log</span> init.s</span><br></pre></td></tr></table></figure><p>We also need to pass these two options to the linker: <code>-Wl-bIVT=0x8000 -Wl-bGSINIT=0x8080</code>. This tells the linker to place IVT section at the beginning followed by GSINIT and rest of the code.</p><p>Eventually, the bootloader ended up occupying around 550 bytes, which I could squeeze down to 500 if I stripped unused interrupt vectors and removed initialization code. And of course the bootloader no longer has to stay unsecured.</p><h2 id="Benchmarking"><a href="#Benchmarking" class="headerlink" title="Benchmarking"></a>Benchmarking</h2><p>Let’s see whether the upload speed is any good. First, let’s upload an empty 6k binary via SWIM with stm8flash:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ time stm8flash -c stlinkv2 -p stm8s003f3 -w empty.bin</span><br><span class="line">Determine FLASH area</span><br><span class="line">Writing binary file 6144 bytes at 0x8000... OK</span><br><span class="line">Bytes written: 6144</span><br><span class="line"></span><br><span class="line">real    0m2.789s</span><br><span class="line">user    0m0.000s</span><br><span class="line">sys     0m0.024s</span><br></pre></td></tr></table></figure><p>Now let’s repeat the same test with the bootloader:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ time python boot.py empty.bin</span><br><span class="line">Need to send 96 chunks</span><br><span class="line">64</span><br><span class="line">128</span><br><span class="line">192</span><br><span class="line">...</span><br><span class="line">6144</span><br><span class="line">Done</span><br><span class="line"></span><br><span class="line">real    0m1.596s</span><br><span class="line">user    0m0.048s</span><br><span class="line">sys     0m0.008s</span><br></pre></td></tr></table></figure><p>Not bad. Initially, I wanted to compare the upload speed against the official STVP programming utility, but I was too lazy to register on ST’s website solely for the purpose of downloading this utility. So let’s just say that it’s good enough.</p><p>Overall, I’m quite pleased with the results. Despite SDCC having a few limitations, none of them were show-stopping and the bootloader ended up being reasonably compact and fast.</p><p>As always, code is on <a href="https://github.com/lujji/stm8-bootloader">github</a>.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;This article will cover developing a serial bootloader for STM8S microcontrollers.&lt;/p&gt;</summary>
    
    
    
    
    <category term="sdcc" scheme="http://lujji.github.io/blog/tags/sdcc/"/>
    
    <category term="stm8" scheme="http://lujji.github.io/blog/tags/stm8/"/>
    
    <category term="bootloader" scheme="http://lujji.github.io/blog/tags/bootloader/"/>
    
    <category term="tutorial" scheme="http://lujji.github.io/blog/tags/tutorial/"/>
    
  </entry>
  
  <entry>
    <title>Mixing C and assembly on STM8</title>
    <link href="http://lujji.github.io/blog/mixing-c-and-assembly-on-stm8/"/>
    <id>http://lujji.github.io/blog/mixing-c-and-assembly-on-stm8/</id>
    <published>2017-07-31T21:00:00.000Z</published>
    <updated>2017-08-03T17:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>This guide discusses how we should (and should not) speed up our code with inline assembly and explains how to write separate assembly routines that can be used within C.</p><span id="more"></span><h2 id="Inline-assembly-and-optimizations"><a href="#Inline-assembly-and-optimizations" class="headerlink" title="Inline assembly and optimizations"></a>Inline assembly and optimizations</h2><p>Let’s take a simple code snippet for toggling an IO pin:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD_ODR ^= (<span class="number">1</span> &lt;&lt; PIN4);</span><br></pre></td></tr></table></figure><p>Now let’s look at the assembly instructions generated by SDCC:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ld  a, 0x500f</span><br><span class="line">xor a, #0x10</span><br><span class="line">ldw x, #0x500f</span><br><span class="line">ld  (x), a</span><br></pre></td></tr></table></figure><p>That’s 4 instructions just to toggle a pin, I’m pretty sure we can do better than that.</p><p>First, let’s familiarize ourselves with CPU registers: we have an 8-bit accumulator register A and two 16-bit registers X and Y. The stack pointer is 16-bit wide and the program counter has 24 bits, but we’re only using the lower 16 bits on processors with &lt;64k of flash.</p><img src="/blog/mixing-c-and-assembly-on-stm8/cpu_registers.png" alt="CPU registers" title="CPU registers"><p>You can find all instructions and other CPU-related stuff is in the <a href="http://www.st.com/resource/en/programming_manual/cd00161709.pdf">programming manual</a>. STM8 has 3 dedicated instructions that take only one cycle to execute: Bit Set (BSET), Bit Reset (BRES) and Bit Complement (BCPL). The last instruction is used to flip a single bit leaving other bits unchanged. We can use these instructions to control individual IO pins as fast as possible:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIND4_SET()     __asm__(<span class="meta-string">&quot;bset 0x500f, #4&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIND4_RESET()   __asm__(<span class="meta-string">&quot;bres 0x500f, #4&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIND4_TOGGLE()  __asm__(<span class="meta-string">&quot;bcpl 0x500f, #4&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>Another usage is clearing pending interrupt flags:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tim4_isr</span><span class="params">()</span> __<span class="title">interrupt</span><span class="params">(TIM4_ISR)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">__asm__</span>(<span class="string">&quot;bres 0x5344, #0&quot;</span>); <span class="comment">// TIM4_SR &amp;= ~(1 &lt;&lt; TIM4_SR_UIF)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To be honest I’m not a big fan of inline assembly - it makes code less readable and harder to maintain. In fact, these optimizations should have been made by the compiler in the first place. SDCC has a rule based pattern matching optimizer, which can be extended with our custom rules. We can use the following pattern that matches the example above:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reg ^= (1 &lt;&lt; 4) -&gt; bcpl reg, #4</span></span><br><span class="line">replace restart &#123;</span><br><span class="line">    ld a, %<span class="number">1</span></span><br><span class="line">    xor a, #<span class="number">0x10</span></span><br><span class="line">    ldw %<span class="number">2</span>, #%<span class="number">1</span></span><br><span class="line">    ld (%<span class="number">2</span>), a</span><br><span class="line">&#125; by &#123;</span><br><span class="line">    bcpl %<span class="number">1</span>, #<span class="number">4</span></span><br><span class="line">&#125; <span class="function"><span class="keyword">if</span> <span class="title">notUsed</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure><p>Save this rule under ‘extra.def’ and compile with <code>--peep-file extra.def</code> option. Since I didn’t find any better solution, I wrote a script that generates patterns for every single bit shift. You can find the rule as well as the python script on <a href="https://github.com/lujji/stm8-bare-min/tree/master/stm8/util">github</a>.</p><h2 id="Accessing-C-symbols-from-assembly"><a href="#Accessing-C-symbols-from-assembly" class="headerlink" title="Accessing C symbols from assembly"></a>Accessing C symbols from assembly</h2><p>SDCC generates symbol names for C variables with an underscore - knowing that makes it possible to access these variables from assembly. Let’s write a small function that increments a 16-bit variable <code>val</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint16_t</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc_val</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">        ldw x, _val</span><br><span class="line">        incw x</span><br><span class="line">        ldw _val, x</span><br><span class="line">    __endasm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s a slight issue with this function, though: we’re modifying a commonly used register X, which means that if some value was loaded before calling the function, it will be lost. The compiler does not know about this - it just places assembly instructions where we told it to. The proper way is to save the contents of the registers before altering them and restore them afterwards.</p><p>That being said, in our case saving registers is not really necessary. There are two calling conventions for assembly functions: caller saves and callee saves. The first one means that functions are allowed to modify registers as they please and function caller is responsible for saving and restoring context. The second one means that any register modified by the function must be restored by the function itself when the it returns.</p><p>According to the <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf">documentation</a>, SDCC uses caller saves convention by default, which means that we can implement our functions without saving the context. But I would still prefer doing it the ‘right way’, since this would allow inlining the function without any consequences:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inc_val</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">        pushw x</span><br><span class="line">        ldw x, _val</span><br><span class="line">        incw x</span><br><span class="line">        ldw _val, x</span><br><span class="line">        popw x</span><br><span class="line">    __endasm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Separate-assembly-functions"><a href="#Separate-assembly-functions" class="headerlink" title="Separate assembly functions"></a>Separate assembly functions</h2><p>OK, but what if we wanted to build our own function with <del>blackjack</del> parameters and return value? Well, for the return value SDCC seems to follow this convention: accumulator is used for storing 8-bit return value, index register X for 16-bit values, and both X and Y are used if we need to return a 32-bit value. Things are a bit more complicated with function parameters, so it’s better to explain this with an example. Let’s implement a fast <code>memcpy</code> that would copy up to 255 bytes. First we declare a prototype with external linkage:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fast_memcpy</span><span class="params">(<span class="keyword">uint8_t</span> *dest, <span class="keyword">uint8_t</span> *src, <span class="keyword">uint8_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>Next we create a file called util.s where we implement this function in assembly:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.module UTIL</span><br><span class="line">.globl _fast_memcpy</span><br><span class="line">.area CODE</span><br><span class="line"><span class="symbol">_fast_memcpy:</span></span><br><span class="line">    ldw x, (<span class="number">0x03</span>, <span class="built_in">sp</span>) <span class="comment">; dest</span></span><br><span class="line">    ldw y, (<span class="number">0x05</span>, <span class="built_in">sp</span>) <span class="comment">; src</span></span><br><span class="line"><span class="symbol">loop0$:</span></span><br><span class="line">    tnz (<span class="number">0x07</span>, <span class="built_in">sp</span>)    <span class="comment">; if (len == 0)</span></span><br><span class="line">    <span class="keyword">jreq </span>loop0_end$</span><br><span class="line">    ld a, (y)         <span class="comment">; loop body</span></span><br><span class="line">    ld (x), a</span><br><span class="line">    incw x</span><br><span class="line">    incw y</span><br><span class="line">    dec (<span class="number">0x07</span>, <span class="built_in">sp</span>)    <span class="comment">; len--</span></span><br><span class="line">    <span class="keyword">jra </span>loop0$</span><br><span class="line"><span class="symbol">loop0_end$:</span></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>All right, let’s figure out what’s going on here. First of all we have <code>.globl</code> - that means we make a symbol accessible from the outside world, and <code>.area</code> - code section. Now for the function itself - the first instruction is <code>ldw x, (0x03, sp)</code>. Here’s how you read it: we get a value from the stack located at [SP + 3]. This value is then treated as a memory address, and the processor loads the value from that address into register X. Just like with pointers in C you can think of <code>ldw (x), y</code> as <code>*((uint16_t *) &amp;x) = y</code>.</p><p>But what’s the deal with those values - 0x03 and 0x05? When we call a function, we (unsurprisingly) issue a <code>call</code> instruction. The programming manual describes what the instruction does: it saves the high and low bytes of Program Counter (PC) register on the stack and loads PC with the destination address of the function being called. At the end of our function we issure a <code>ret</code> instruction which restores PC. Stack pointer decreases when you push something on the stack, so if we offset it by 1, we get the address of the last byte that was pushed on the stack (which is PCH), if we offset it by 2 we get PCL and if we offset it by 3 - bingo! We get the first argument that was passed to the function. Since the first two arguments are pointers, each of them will occupy 2 bytes on the stack. So the offset for the second argument would be 0x03 + 2 &#x3D; 0x05.</p><p>The rest of the code is pretty much self-explanatory: we jump to <code>loop_end</code> if the third argument (len) is 0, otherwise we continue with the main loop which copies source byte into destination address, increments the pointers and decrements len. The last thing is to assemble our source:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdasstm8 -lo util.s</span><br></pre></td></tr></table></figure><p>Options <code>-lo</code> tell the assembler to create list and object files respectively. That’s it, now we can link <code>util.rel</code> with our program and call the assembly subroutine directly from C code.</p><p>As always, code is on <a href="https://github.com/lujji/stm8-bare-min/tree/master/examples/ASM">github</a>.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;This guide discusses how we should (and should not) speed up our code with inline assembly and explains how to write separate assembly routines that can be used within C.&lt;/p&gt;</summary>
    
    
    
    
    <category term="sdcc" scheme="http://lujji.github.io/blog/tags/sdcc/"/>
    
    <category term="stm8" scheme="http://lujji.github.io/blog/tags/stm8/"/>
    
    <category term="assembly" scheme="http://lujji.github.io/blog/tags/assembly/"/>
    
  </entry>
  
  <entry>
    <title>Executing code from RAM on STM8</title>
    <link href="http://lujji.github.io/blog/executing-code-from-ram-on-stm8/"/>
    <id>http://lujji.github.io/blog/executing-code-from-ram-on-stm8/</id>
    <published>2017-07-25T21:00:00.000Z</published>
    <updated>2017-07-26T20:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>A short article where we investigate how executing code from RAM can be achieved on STM8 with SDCC toolchain.</p><span id="more"></span><p>All right, I’ve been avoiding this topic for quite a while, so I wanted to deal with it first before finishing other articles. The reason for me to avoid this topic was mostly because I needed to come up with a relatively clean solution that would be worth writing about. I had an assumption that SDCC was not the right tool for the job, and some of the hacks that I came across while researching this topic only made this assumption stronger. But I’m more than glad to say that I was wrong.</p><p>Overall the mechanism for copying functions into RAM is not complicated: you place your function in a separate code section, reserve some memory for this function and finally, copy the contents of this section into RAM. The hardest part is to figure out how to accomplish all that with SDCC toolchain. Let’s find out.</p><p>First of all, SDCC port for STM8 supports <code>--codeseg</code> option, which can be also invoked via a pragma. In order to place a function into a specific code section we have to implement this function in a separate .c file, compile it and link with our application. For this example we’ll take a function that sends a null-terminated string over UART:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> codeseg RAM_SEG</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ram_uart_puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        UART1_DR = *str++;</span><br><span class="line">        <span class="keyword">while</span> (!(UART1_SR &amp; (<span class="number">1</span> &lt;&lt; UART1_SR_TC)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After compiling the source we should be able to see <code>.area RAM_SEG</code> above <code>_ram_uart_puts</code> symbol in the output listing.</p><p>Now that we have a separate section containing a single function, we need to find some way of getting the section length in order to know how many bytes to copy. For that we’ll resort to <a href="http://svn.code.sf.net/p/sdcc/code/trunk/sdcc/sdas/doc/asmlnk.txt">SDCC ASxxxx Assemblers documentation</a>, which is an impressively large document, but don’t worry - we’ll only need small portions of it.</p><p>‘General assembler directives’ section tells us that assembler generates two symbols for each program area (code section): <code>s_&lt;area&gt;</code>, which is the starting address of the program area and <code>l_&lt;area&gt;</code> - length of that program area. Unfortunately, you can’t access these variables directly from C. But you can access C variables from assembly, which means that retrieving code section length can be achieved with just a single line of assembly code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> RAM_SEG_LEN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_ram_section_length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">__asm__</span>(<span class="string">&quot;mov _RAM_SEG_LEN, #l_RAM_SEG&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here I’m assuming that the function is small enough to fit into 255 bytes. If that’s not the case, things become a bit more complicated:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint16_t</span> RAM_SEG_LEN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_ram_section_length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">        pushw x</span><br><span class="line">        ldw x, #l_RAM_SEG</span><br><span class="line">        ldw _RAM_SEG_LEN, x</span><br><span class="line">        popw x</span><br><span class="line">    __endasm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We’re using <code>ldw</code> instruction to load the section length into a 16-bit index register X, which is then copied into uint16_t variable RAM_SEG_LEN. Note that symbol names of C variables are generated with a leading underscore. Also note that the code snippet is surrounded with pushw&#x2F;popw instructions - this is done to preserve the contents of register X since we don’t want our inline function to break any other code that might be using this register.</p><p>Now the last remaining thing is to copy the subroutine into RAM:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> f_ram[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">void</span> (*uart_puts)(<span class="keyword">const</span> <span class="keyword">char</span> *str);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ram_cpy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    get_ram_section_length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0</span>; i &lt; RAM_SEG_LEN; i++)</span><br><span class="line">        f_ram[i] = ((<span class="keyword">uint8_t</span> *) ram_uart_puts)[i];</span><br><span class="line">    uart_puts = (<span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">char</span> *)) &amp;f_ram;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since there is no elegant way of getting code section length at compile-time, we simply declare an array of fixed size and make sure that it’s large enough to store our RAM functions. SDCC does not support variable-length arrays, so we can’t allocate this memory on the stack either. A nicer workaround would be to use <code>malloc()</code>, but it just feels wrong. We <em>could</em> of course reserve the exact amount of bytes in the .data section in assembly and declare f_ram as extern. But here’s a thing about assembly: once you start optimizing things, it’s really hard to stop. Quite often I come across some code which contains so much inline assembly that makes me wonder why the author bothered with C in the first place.</p><p>Keep in mind that some processor instructions can use both absolute and relative addressing, which might ruin your day when relocating functions with external dependencies, so make sure that you always check the listing. The general rule is: addressing within the function itself must be relative and accessing external symbols must be done via an absolute address. Minimizing external dependencies and keeping RAM functions compact and self-contained will definitely help preserving your sanity.</p><p>That’s it for now. As always, code is on <a href="https://github.com/lujji/stm8-bare-min/tree/master/examples/RAM_EXEC">github</a>.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;A short article where we investigate how executing code from RAM can be achieved on STM8 with SDCC toolchain.&lt;/p&gt;</summary>
    
    
    
    
    <category term="sdcc" scheme="http://lujji.github.io/blog/tags/sdcc/"/>
    
    <category term="stm8" scheme="http://lujji.github.io/blog/tags/stm8/"/>
    
    <category term="assembly" scheme="http://lujji.github.io/blog/tags/assembly/"/>
    
  </entry>
  
  <entry>
    <title>Bare metal programming: STM8 (Part 2)</title>
    <link href="http://lujji.github.io/blog/bare-metal-programming-stm8-part2/"/>
    <id>http://lujji.github.io/blog/bare-metal-programming-stm8-part2/</id>
    <published>2017-04-10T21:00:00.000Z</published>
    <updated>2017-07-30T00:51:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>In this part we are going to focus on more features of STM8 (clock, EEPROM, option bytes, flash access) and stick some wires into the mains outlet.</p><span id="more"></span><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents:"></a>Contents:</h2><ul><li><a href="#Clock">Clock</a></li><li><a href="#EEPROM">EEPROM</a></li><li><a href="#Option-bytes">Option bytes</a></li><li><a href="#Flash">Flash</a></li></ul><h2 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h2><p>STM8 can run on one of 3 different clock sources:</p><ul><li>External clock&#x2F;crystal oscillator (HSE)</li><li>Internal 16 MHz RC oscillator (HSI)</li><li>Internal 128 khz RC oscillator (LSI)</li></ul><p>These clock sources determine the frequency of master clock which clocks the CPU and peripherals. HSI clock can be scaled down by adjusting 2-bit <code>HSIDIV</code> prescaler. At startup the master clock source is automatically selected as HSI &#x2F; 8, which results in 2 MHz. It is possible to decrease CPU frequency by increasing the prescaler value in <code>CPUDIV</code> register. By default the prescaler is set to 1.</p><p>In the <a href="/blog/bare-metal-programming-stm8">previous part</a> we didn’t bother configuring clocks and therefore were running at 2 MHz. This time we’ll be using an external crystal connected between PA1 and PA2 pins. Before we start configuring clocks, let’s take advantage of processor’s clock output capability - this will allow us to perform a sanity check and see if we configured things properly.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_LSI_CCO       0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_HSE_CCO       0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_CPU_CCO       0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_HSI_CCO       0x22</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_out_enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Configure PC4 as output */</span></span><br><span class="line">    PC_DDR |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    <span class="comment">/* Push-pull mode, 10MHz output speed */</span></span><br><span class="line">    PC_CR1 |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    PC_CR2 |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    <span class="comment">/* Clock output on PC4 */</span></span><br><span class="line">    CLK_CCOR |= (<span class="number">1</span> &lt;&lt; CLK_CCOR_CCOEN) | F_CPU_CCO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Various clock output options are available in the <code>CLK_CCOR</code> register - I defined some of the possible ones so that you get the idea.</p><p>Enabling external oscillator is done by setting <code>HSEEN</code> bit in <code>CLK_ECKR</code> register. As soon as the oscillator is ready (which is indicated by <code>HSERDY</code> bit), we need to switch the master clock to HSE by writing 0xB4 into <code>CLK_SWR</code>. Finally, we wait until the clock source is stabilized and execute the clock switch by setting <code>SWEN</code> bit in <code>CLK_SWCR</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hse_enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Enable HSE crystal oscillator */</span></span><br><span class="line">    CLK_ECKR |= (<span class="number">1</span> &lt;&lt; CLK_ECKR_HSEEN);</span><br><span class="line">    <span class="keyword">while</span> (!(CLK_ECKR &amp; (<span class="number">1</span> &lt;&lt; CLK_ECKR_HSERDY)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch master clock to HSE */</span></span><br><span class="line">    CLK_SWR = <span class="number">0xB4</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(CLK_SWCR &amp; (<span class="number">1</span> &lt;&lt; CLK_SWCR_SWIF)));</span><br><span class="line">    CLK_SWCR |= (<span class="number">1</span> &lt;&lt; CLK_SWCR_SWEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="External-clock"><a href="#External-clock" class="headerlink" title="External clock"></a>External clock</h3><p>There is a nice trick when you need to sync two or more microcontrollers: instead of using a crystal you can supply an external clock to the oscillator input pin and leave the other pin floating. STM8 even has a dedicated mode for external clock source, which can be activated by enabling <code>EXTCLK</code> option bit.</p><p>The procedure for enabling external clock is identical to enabling HSE, except that we don’t write <code>HSEEN</code> bit, since we’re not driving an oscillator. In this case I used automatic clock switching mechanism: the only difference is that it allows the processor to run and execute instructions while the clock is being stabilized, although I’m still polling for <code>SWIF</code> since I want to stall the CPU until the clock switching is complete.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">external_clock_enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* set prescaler to 1 */</span></span><br><span class="line">    CLK_CKDIVR = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch master clock to HSE */</span></span><br><span class="line">    CLK_SWCR |= (<span class="number">1</span> &lt;&lt; CLK_SWCR_SWEN);</span><br><span class="line">    CLK_SWR = <span class="number">0xB4</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(CLK_SWCR &amp; (<span class="number">1</span> &lt;&lt; CLK_SWCR_SWIF)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After connecting the external clock source to OSCIN (PA1), we need to enable <code>EXTCLK</code> option bit by writing 0x08 into <code>OPT4</code> (option bytes will be discussed later on). Finally, we call <code>external_clock_enable()</code> and wait until the CPU switches clocks. We can ensure that clock switching is successful by enabling clock output and probing CLK_CCO pin.</p><p>The external clock source has to be a square wave with 50% duty cycle. According to the documentation, sine and triangle waveforms can be used as clock sources as well. The datasheet also claims that minimum CPU frequency is 0 Hz.</p><p>So, presumably, it’s possible to clock the CPU from a sinusoidal signal with frequency all the way down to DC. Ugh.. the temptation is irresistible. I don’t have a signal generator. <em>But I do have mains AC.</em></p><img src="/blog/bare-metal-programming-stm8-part2/50hz_clk.jpg" alt="What could possibly go wrong?" title="What could possibly go wrong?"><p>Surprisingly, it worked. In case you’re wondering, the chip was able to survive 230V applied to it due to the fact that every pin on STM8 (except for ‘true open-drain’ pins) has protection diodes to Vcc and ground. These diodes will clamp any excessive voltages and prevent the part from releasing the magic smoke. Having a large value series resistor limits the current flowing through these diodes. The documentation doesn’t specify maximum current for clamping diodes, but it’s usually a good idea to keep it below 1mA. Keep in mind that when the diodes conduct the current has to return <em>somewhere</em> - in this case it’s the lithium battery. Did I mention that it’s not a particularly good idea?</p><h3 id="A-less-lethal-approach"><a href="#A-less-lethal-approach" class="headerlink" title="A less lethal approach"></a>A less lethal approach</h3><p>Although clocking the MCU directly from mains was kind of fun, I felt rather uncomfortable working when the microcontroller is live. Since I still wanted to find out how useful a mains-clocked processor is, I decided to make things a bit less hazardous by adding some opto-isolation.</p><p>I discovered that the clock input circuitry does not like low frequency signals with slow edges. Feeding the output of the opto-isolator directly into the microcontroller results in random glitches on the clock output due to false triggering, and occasionally the CPU just locks up. Applying mains directly worked better since the slew rate was higher in that case. The datasheet hints that HSE has to be above 1 MHz for external crystal, but doesn’t specify the lower limit for external user clock. I’m pretty sure we can get stable operation if we improve transition speed. For this purpose we’ll need to use a Schmitt trigger, which is basically a comparator with hysteresis, to convert the output of the optocoupler into a nice and clean square wave.</p><p>There are dedicated Schmitt trigger ICs and even opto-isolators with Schmitt trigger outputs - non of these do I have at hand. One can implement a Schmitt trigger using an op-amp, but if you want to save a few resistors you can use a good old 555 timer. The 555 has two comparators configured to fire off when voltage on their inputs reaches 1&#x2F;3 and 2&#x2F;3 Vcc respectively, which is just about right to set the hysteresis. Comparator inputs are pins 2 (Trigger) and 6 (Threshold). Below is the resulting schematic.</p><img src="/blog/bare-metal-programming-stm8-part2/schematic.jpg" alt="""" title=""""><p>R1 is limiting the current flowing through the LED inside the optocoupler and D1 guarantees that reverse breakdown voltage of the LED would not be exceeded during the negative half cycle of the sine wave. Resistor values depend on the optocoupler being used. In my case I used LTV-817 (Vf &#x3D; 1.2V) and R1 will limit the peak current to Ipeak &#x3D; (325 - 1.2) &#x2F; 180000 &#x3D; 1.8mA. Since the threshold is fixed, I had to adjust R2 to get as close to 50% duty cycle as possible, which is why it’s value ended up being higher than it should be.</p><p>The only timer that I had was NE555 - it’s quite a slow chip not rated for 3.3V operation. A CMOS timer like LMC555 would be a much better choice. That being said, the resulting waveform is still acceptable.</p><img src="/blog/bare-metal-programming-stm8-part2/555_schmitt_trigger.png" alt="Schmitt Trigger" title="Schmitt Trigger"><p>The duty cycle isn’t precisely 50% and the edges are a bit jagged and jittery, but still good enough for the processor to latch onto.</p><img src="/blog/bare-metal-programming-stm8-part2/555_edge.png" alt="""" title=""""><p>After connecting the output of the Schmitt trigger to OSCIN, I ensured that I was getting a stable 50 Hz output on CLK_CCO pin and tried bringing up various peripherals. Below is the sped up footage of one of my experiments.</p><img src="/blog/bare-metal-programming-stm8-part2/spi_50hz.gif" alt="That took about 3 minutes.." title="That took about 3 minutes.."><p>Well, that was the slowest SPI communication I’ve ever seen. Nevertheless, it was nice to know that the processor is still usable at such low clock frequencies.</p><h2 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h2><p>EEPROM is a small area of memory that can be used for storing things like configuration, calibration data, etc. On STM8S003 EEPROM starts at address 0x4000 and ends at 0x407F, which results in stunning 128 bytes of data. Let’s define some macros first. We’ll use the first macro for memory access, just like we did with register definitions in <a href="/blog/bare-metal-programming-stm8/#It%E2%80%99s-all-just-memory">part 1</a>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MEM_(mem_addr)         (*(volatile uint8_t *)(mem_addr))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EEPROM_START_ADDR       0x4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EEPROM_END_ADDR         0x407F</span></span><br></pre></td></tr></table></figure><p>By default, EEPROM is write protected and a specific sequence is required in order to unlock it: two hardware keys have to be written into <code>FLASH_DUKR</code> register. The first time I tried programming EEPROM it didn’t work. The reason was me ignoring the following statement in the reference manual: <em>“before starting programming, the application must verify that the DATA area is not write protected”</em>. I interpreted it as “you shouldn’t write into write-protected areas” while the real meaning was “it takes some time to unlock EEPROM”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_write</span><span class="params">(<span class="keyword">uint16_t</span> addr, <span class="keyword">uint8_t</span> *buf, <span class="keyword">uint16_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* unlock EEPROM */</span></span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY1;</span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data from buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i = <span class="number">0</span>; i &lt; len; i++, addr++) &#123;</span><br><span class="line">        _MEM_(addr) = buf[i];</span><br><span class="line">        <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_EOP)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock EEPROM */</span></span><br><span class="line">    FLASH_IAPSR &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that on low density STM8S microcontrollers the CPU is stalled during EEPROM write operation, therefore it is not necessary to poll for <code>EOP</code> flag.</p><p>Reading EEPROM is achieved the same way you read any other memory:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_read</span><span class="params">(<span class="keyword">uint16_t</span> addr, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* read EEPROM data into buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++, addr++)</span><br><span class="line">        buf[i] = _MEM_(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interestingly, <a href="http://www.st.com/resource/en/programming_manual/cd00191343.pdf">flash programming manual</a> states that on low density devices, EEPROM is comprised of additional 640 bytes of memory located in the same memory array with flash. In other words, it seems like there are 10 pages of flash memory reserved for EEPROM. Also, the manual gives the exact value (it doesn’t say <em>up to</em> 640 bytes), which contradicts with the datasheet.</p><p>Let’s try shifting <code>EEPROM_END_ADDR</code> to 0x4280 and filling the whole range with dummy bytes:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY1;</span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> addr = EEPROM_START_ADDR; addr &lt; EEPROM_END_ADDR; addr++)</span><br><span class="line">        _MEM_(addr) = <span class="number">0xAA</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we can dump EEPROM and check if it was written. I deliberately specified <code>stm8s103f3</code> to read more memory than our part has.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stm8flash -c stlinkv2 -p stm8s103f3 -s eeprom -r dump.bin</span><br></pre></td></tr></table></figure><p>Yeap, it worked on every processor that I tried. Although I would rather prefer having a bit more flash memory, it’s still good to know that STM8S003 has some extra EEPROM.</p><h2 id="Option-bytes"><a href="#Option-bytes" class="headerlink" title="Option bytes"></a>Option bytes</h2><p>Option bytes are located in the EEPROM and allow configuring device hardware features such as readout protection and alternate function mapping. Each option byte, except for read-out protection, has to be stored in a normal form (OPTx) and complementary form (NOPTx). The procedure for writing option bytes is the same as for writing EEPROM, except for the unlcok sequence: <code>OPT</code> bit has to be set in <code>FLASH_CR2</code> and <code>FLASH_NCR2</code> registers.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">opt_write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* new value for OPT5 (default is 0x00) */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> opt5 = <span class="number">0xb4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock EEPROM */</span></span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY1;</span><br><span class="line">    FLASH_DUKR = FLASH_DUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock option bytes */</span></span><br><span class="line">    FLASH_CR2 |= (<span class="number">1</span> &lt;&lt; FLASH_CR2_OPT);</span><br><span class="line">    FLASH_NCR2 &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_NCR2_NOPT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write option byte and it&#x27;s complement */</span></span><br><span class="line">    OPT5 = opt5;</span><br><span class="line">    NOPT5 = ~opt5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until programming is finished */</span></span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_EOP)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock EEPROM */</span></span><br><span class="line">    FLASH_IAPSR &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_IAPSR_DUL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you mess things up, you can reset the option bytes via SWIM:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -ne <span class="string">&#x27;\x00\x00\xff\x00\xff\x00\xff\x00\xff\x00\xff&#x27;</span> &gt; opt.bin</span><br><span class="line">$ stm8flash -c stlinkv2 -p stm8s003f3 -s opt -w opt.bin</span><br></pre></td></tr></table></figure><p>Interestingly, if we read the memory a bit further, we find a section which contains the following data:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x480B: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x4823: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x483B: 00 00 00 00 00 0c f3 12 ed 12 ed cd 32 77 88 49 b6 01 fe 20 df 03 fc 01</span><br><span class="line">0x4853: fe 00 00 00 00 00 00 00 00 00 00 00 00 57 00 1f 5b 00 00 1e 00 3f 07 47</span><br><span class="line">0x486B: 36 31 34 32 31 33 1f 00 00 1f 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>20 bytes at address 0x4840 are written with their complement values just like the option bytes. This whole block is write protected and differs slightly from one processor to another - unique ID perhaps?</p><h2 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h2><p>One thing that I like the most about STM8 is flash access.</p><p>The two most common types of flash memory are NAND and NOR flash. Flash is physically divided into blocks, which may be further divided into sectors. The entire memory is linear and can be read or written in a random access fashion, however both NAND and NOR flash share the same disadvantage: you can flip a 1 into a 0 but not vice-versa. The only way to flip a 0 back to 1 is to erase the whole block. If you need to overwrite a few bytes in flash memory you have to buffer the whole page into RAM, modify the buffer, erase flash page and write the buffer back into flash memory - the whole process is rather time-consuming.</p><p>With STM8 this is not the case: the whole memory can be accessed at byte level. You can write any byte inside any page and erase it by simply writing 0x00 at that address. Essentially, you can treat flash memory as a large EEPROM.</p><p>Removing write protection is almost identical to unprotecting EEPROM.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flash_write</span><span class="params">(<span class="keyword">uint16_t</span> addr, <span class="keyword">uint8_t</span> *buf, <span class="keyword">uint16_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* unlock flash */</span></span><br><span class="line">    FLASH_PUKR = FLASH_PUKR_KEY1;</span><br><span class="line">    FLASH_PUKR = FLASH_PUKR_KEY2;</span><br><span class="line">    <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_PUL)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data from buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i = <span class="number">0</span>; i &lt; len; i++, addr++) &#123;</span><br><span class="line">        _MEM_(addr) = buf[i];</span><br><span class="line">        <span class="keyword">while</span> (!(FLASH_IAPSR &amp; (<span class="number">1</span> &lt;&lt; FLASH_IAPSR_EOP)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock flash */</span></span><br><span class="line">    FLASH_IAPSR &amp;= ~(<span class="number">1</span> &lt;&lt; FLASH_IAPSR_PUL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Just like with EEPROM, we can dump the entire flash memory:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stm8flash -c stlinkv2 -p stm8s003f3 -s flash -r dump.bin</span><br></pre></td></tr></table></figure><p>SDCC has various attributes like <code>__xdata</code> and <code>__eeprom</code> for placing things in specific memory locations. Unfortunately, none of them are implemented for STM8 yet. We can partially work around this limitation by using <code>__at</code> attribute:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Use last 64 bytes of flash for user data */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID_ADDR                 (0x8000 + 0x1FC0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_DATA_ADDR          (ID_ADDR + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tell compiler where the variables are located */</span></span><br><span class="line">__at(USER_DATA_ADDR) <span class="keyword">uint8_t</span> data[<span class="number">8</span>];</span><br><span class="line">__at(ID_ADDR) <span class="keyword">const</span> <span class="keyword">uint8_t</span> id = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>Let’s take a closer look at the above example: first we define two addresses in flash memory. Remember that program memory starts at 0x8000, so we add this value to get the address we want. Next we declare <code>data</code> array with attribute <code>__at(USER_DATA_ADDR)</code> - this tells the compiler where to look when the variable is being accessed. For example, a read operation on <code>data[2]</code> will return the value at address 0x9FC3, which is the same as calling <code>_MEM_(0x9FC3)</code>. Same goes for write operation: if flash is unlocked, then writing <code>data[2]</code> will store the value at the appropriate address in flash memory. If flash unlock sequence was not executed before performing a write, then <code>WR_PG_DIS</code> bit will be set in <code>FLASH_IAPSR</code> register to indicate an attempt to modify write-protected page.</p><p>The second variable <code>id</code> is declared as <code>const</code> - this will actually produce a binary with the value placed at specified memory address. Declaring a variable as constant means that compiler will not allow us to perform explicit write operations, unless we write directly at the specified address (which kind of defeats the purpose of <code>const</code> qualifier). Unfortunately, this approach will not work for EEPROM - SDCC will simply produce a larger binary image.</p><hr><p>That’s it for now. In the next part we’re going to take a look at some of the features essential for real-world applications and discuss questions of reliability and performance. As always, code is available on <a href="https://github.com/lujji/stm8-bare-min">github</a>. Since previous article the repository evolved into a small peripheral library with dedicated examples directory.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;In this part we are going to focus on more features of STM8 (clock, EEPROM, option bytes, flash access) and stick some wires into the mains outlet.&lt;/p&gt;</summary>
    
    
    
    
    <category term="bare-metal" scheme="http://lujji.github.io/blog/tags/bare-metal/"/>
    
    <category term="sdcc" scheme="http://lujji.github.io/blog/tags/sdcc/"/>
    
    <category term="stm8" scheme="http://lujji.github.io/blog/tags/stm8/"/>
    
  </entry>
  
  <entry>
    <title>Bare metal programming: STM8</title>
    <link href="http://lujji.github.io/blog/bare-metal-programming-stm8/"/>
    <id>http://lujji.github.io/blog/bare-metal-programming-stm8/</id>
    <published>2017-03-03T22:00:00.000Z</published>
    <updated>2023-02-14T11:37:17.395Z</updated>
    
    <content type="html"><![CDATA[<p>This article will cover developing for STM8 series of microcontrolles completely from scratch, without using any vendor-supplied libraries.</p><span id="more"></span><hr><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>STM8 is a cheap 8-bit microcontroller aimed towards low-cost mass-market devices. Initially I came across this part while searching for a simple microcontroller as a replacement for AVRs. Despite having various ARM Cortex-M0 devices available on the market for quite attractive prices, AVRs have one advantage - simplicity. Utilizing an ARM Cortex core to switch some lights on and off seems like an overkill. Some applications just don’t require that amount of flexibility and performance.</p><p>The main goal of this article is to demonstrate that ‘bare metal’ programming is not a difficult task and to give you an overview of STM8’s architecture and peripherals. Even though writing peripheral drivers from scratch might seem like reinventing the wheel, in many cases it is easier and faster to implement the functionality that <em>you</em> need for a specific task, instead of relying on vendor-supplied libraries that try to do everything at once (and fail).</p><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents:"></a>Contents:</h2><ul><li><a href="#The-Hardware">The Hardware</a></li><li><a href="#Setting-up-toolchain">Setting up toolchain</a></li><li><a href="#It%E2%80%99s-all-just-memory">It’s all just memory..</a></li><li><a href="#First-program">First program</a></li><li><a href="#Peripheral-drivers">Peripheral drivers</a><br>– <a href="#UART">UART</a><br>– <a href="#SPI">SPI</a><br>– <a href="#I2C">I2C</a><br>– <a href="#ADC">ADC</a><br>– <a href="#Timers-and-interrupts">Timers and interrupts</a></li><li><a href="#Putting-it-all-together">Putting it all together</a></li><li><a href="#Conclusion">Conclusion</a></li></ul><h2 id="The-Hardware"><a href="#The-Hardware" class="headerlink" title="The Hardware"></a>The Hardware</h2><p>There is a number of ways to start working with STM8. The easiest one is to get a Discovery board, although I wouldn’t recommend it, since STM8 Discovery boards aren’t that good and the on-board ST-Link v1 firmware just sucks.</p><p>Instead, I’ll opt for the minimalist approach. All you need is an ST-Link v2, STM8S003F3 and a breakout board. STM8S003F3 comes in a handy TSSOP20 package which is very easy to solder.</p><img src="/blog/bare-metal-programming-stm8/breakout.jpg" alt="Poor man's devboard" title="Poor man's devboard"><p><strong><em>Note: a 1uF capacitor on VCAP pin is required for the processor to operate.</em></strong></p><h2 id="Setting-up-toolchain"><a href="#Setting-up-toolchain" class="headerlink" title="Setting up toolchain"></a>Setting up toolchain</h2><p>The biggest downside is that STM8 processors are not supported by GCC. There are 3 commercial compilers available for these processors: Raisonance, Cosmic and IAR. Some of these compilers have free versions with code size limit, but none of them are available for linux. Luckily, SDCC supports STM8 and that’s what we’re going to use. SDCC is being actively developed, so I suggest trying the latest snapshot build instead of the stable version. To program the microcontroller we’ll be using stm8flash. The first step is to download all the necessary tools:</p><ol><li><a href="https://sourceforge.net/projects/sdcc/files/snapshot_builds/">sdcc</a></li><li><a href="https://github.com/vdudouyt/stm8flash">stm8flash</a></li></ol><p>Extract SDCC under ~&#x2F;local&#x2F;sdcc. Now extract stm8flash, build it with <code>make</code> and copy stm8flash binary to ~&#x2F;local&#x2F;sdcc&#x2F;bin. I prefer to keep flasher with compiler for convenience. Next, add the following line to your .bashrc file (replacing <em>username</em> with your user name):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/username/local/sdcc</span><br></pre></td></tr></table></figure><p>If everything was done properly, you should be able to run <code>sdcc --version</code>. The last remaining thing is to write udev rule for ST-Link programmer. Create a file <code>/etc/udev/rules.d/99-stlink.rules</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ST-Link v1/v2</span><br><span class="line">ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;3744&quot;, MODE=&quot;0666&quot;</span><br><span class="line">ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;3748&quot;, MODE=&quot;0666&quot;</span><br></pre></td></tr></table></figure><p>Finally, run <code>udevadm control --reload-rules &amp;&amp; udevadm trigger</code> as root. Now we’re all set and ready to start.</p><h2 id="It’s-all-just-memory"><a href="#It’s-all-just-memory" class="headerlink" title="It’s all just memory.."></a>It’s all just memory..</h2><p>Before we begin, let’s take a simple example of accessing port register on ATmega and see what’s going on under the hood:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Port access operation */</span></span><br><span class="line">PORTB = (<span class="number">1</span> &lt;&lt; PB2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expanding macros (same as above) */</span></span><br><span class="line">(* (<span class="keyword">volatile</span> <span class="keyword">uint8_t</span> *) ((<span class="number">0x05</span>) + <span class="number">0x20</span>)) = (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same as above */</span></span><br><span class="line">* (<span class="keyword">volatile</span> <span class="keyword">uint8_t</span> *) <span class="number">0x25</span> = <span class="number">0x04</span>;</span><br></pre></td></tr></table></figure><p>Typecasting integer to a pointer is a valid operation in C. If you don’t quite understand what is going on with pointer arithmetics then here’s another example for you:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> a = <span class="number">0xDE</span>;  <span class="comment">// a contains 0xDE</span></span><br><span class="line"><span class="keyword">uint8_t</span> *ptr = &amp;a; <span class="comment">// ptr points to a</span></span><br><span class="line">*ptr = <span class="number">0xAD</span>; <span class="comment">// a contains 0xAD</span></span><br></pre></td></tr></table></figure><p>The only difference is that in the first example we know exactly which address in memory we are going to use. It’s important that you understand what’s going on here, since we’re going to use this mechanism for accessing hardware registers later on.</p><h2 id="First-program"><a href="#First-program" class="headerlink" title="First program"></a>First program</h2><p>These are the two most important documents: <a href="st.com/resource/en/datasheet/stm8s003k3.pdf">datasheet</a> and <a href="www.st.com/resource/en/reference_manual/CD00190271.pdf">reference manual</a>. We’ll use the datasheet for the pinout and register map. Everything else is present in the reference manual: peripheral operation, register description, etc. Let’s begin by opening the GPIO section of the reference manual and taking a closer look at PORTD registers.</p><img src="/blog/bare-metal-programming-stm8/portd_registers.png" alt="PORTD registers" title="PORTD registers"><p>These registers are pretty much self-explanatory but just in case, here’s a brief overview: <code>DDR</code> is the direction register, which configures a pin as either an input or an output. After we configured <code>DDR</code> we can use <code>ODR</code> for writing or <code>IDR</code> for reading pin state. Control registers <code>CR1</code> and <code>CR2</code> are used for configuring internal pull-ups, output speed and selecting between push-pull or pseudo open-drain.</p><p>First, let’s define a macro that we’ll use later on for register definitions. Base address for all the hardware registers is 0x5000 so we can hardcode that into our macro.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SFR_(mem_addr)      (*(volatile uint8_t *)(0x5000 + (mem_addr)))</span></span><br></pre></td></tr></table></figure><p>Now let’s try blinking an LED. For this task we need to define <code>ODR</code>, <code>DDR</code> and <code>CR1</code> registers for PORTD. We also need a delay function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_CPU 2000000UL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SFR_(mem_addr)     (*(volatile uint8_t *)(0x5000 + (mem_addr)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PORT D */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_ODR      _SFR_(0x0F)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_DDR      _SFR_(0x11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_CR1      _SFR_(0x12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_PIN     4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(<span class="keyword">uint16_t</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((F_CPU / <span class="number">18000U</span>L) * ms); i++)</span><br><span class="line">        <span class="keyword">__asm__</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PD_DDR |= (<span class="number">1</span> &lt;&lt; LED_PIN); <span class="comment">// configure PD4 as output</span></span><br><span class="line">    PD_CR1 |= (<span class="number">1</span> &lt;&lt; LED_PIN); <span class="comment">// push-pull mode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* toggle pin every 250ms */</span></span><br><span class="line">        PD_ODR ^= (<span class="number">1</span> &lt;&lt; LED_PIN);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Save this in main.c and compile by running the following command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdcc -lstm8 -mstm8 --out-fmt-ihx --std-sdcc11 main.c</span><br></pre></td></tr></table></figure><p>Now attach st-link and flash the microcontroller.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stm8flash -c stlinkv2 -p stm8s003f3 -w main.ihx</span><br></pre></td></tr></table></figure><br/><img src="/blog/bare-metal-programming-stm8/blink.jpg" alt="It's alive!" title="It's alive!"><p>Congratulations! We’ve just written our first program from scratch.</p><p><em>Note: some of the STM8 pins are labeled with <code>(T)</code> in the datasheet. These pins are ‘true’ open-drain and can only pull to ground. You should be extra careful when working with open-drain pins, since there are no protection diodes. I managed to accidentally blow PB5 by using it as a normal GPIO, which took me hours to figure out when my I2C code wasn’t working. One way of checking whether the pin is dead or not is by setting the multimeter in diode mode and measuring the voltage drop between the pin and ground - it should be roughly 0.7V in one direction.</em></p><h2 id="Peripheral-drivers"><a href="#Peripheral-drivers" class="headerlink" title="Peripheral drivers"></a>Peripheral drivers</h2><h3 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h3><p>After toggling some IO pins the first thing that you should get up and running on a new platform is UART. It makes debugging much easier. As always, we begin with register definitions.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UART */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_SR     _SFR_(0x230)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_TXE    7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_TC     6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_RXNE   5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_DR     _SFR_(0x231)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BRR1   _SFR_(0x232)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BRR2   _SFR_(0x233)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_CR1    _SFR_(0x234)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_CR2    _SFR_(0x235)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_TEN    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_REN    2</span></span><br></pre></td></tr></table></figure><p>Usually, in order to initialize UART one has to calculate baud and write the resulting value into the corresponding HIGH and LOW registers. Let’s see how this is done in STM8.</p><img src="/blog/bare-metal-programming-stm8/uart.png" alt="What were they thinking?!" title="What were they thinking?!"><p>So.. you get a 16-bit value and you write the first nibble [15:12] into BRR2[7:4], then you write bits [11:4] into BRR1 and finally you write the remaining bits [3:0] into BRR2[3:0]. Seriously, what were they thinking? Why couldn’t ST just implement BRR_HIGH and BRR_LOW for the sake of it? All this bit-fiddling just seems unnecessarily complicated.</p><p>Anyway, let’s move on to initialization. We’ll stick with the default 8 data bits, 1 stop bit and no parity. Since our master clock is 2MHz, for baud &#x3D; 9600 we have UART_DIV &#x3D; 2000000&#x2F;9600 &#x3D; 208 (0xD0). According to the bizarre diagram above, we end up with BRR1 &#x3D; 0x0D and BRR2 &#x3D; 0x00. One thing to keep in mind is that BRR2 register must be written before BRR1. Finally, we turn on receiver and transmitter in Control Register 2. Read and write functions are pretty straight-forward: you read&#x2F;write the Data Register and wait until the appropriate bit in Status Register is set.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PD5 -&gt; TX</span></span><br><span class="line"><span class="comment"> * PD6 -&gt; RX</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UART_BRR2 = <span class="number">0x00</span>;</span><br><span class="line">    UART_BRR1 = <span class="number">0x0D</span>;</span><br><span class="line">    UART_CR2 = (<span class="number">1</span> &lt;&lt; UART_TEN) | (<span class="number">1</span> &lt;&lt; UART_REN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_write</span><span class="params">(<span class="keyword">uint8_t</span> data)</span> </span>&#123;</span><br><span class="line">    UART_DR = data;</span><br><span class="line">    <span class="keyword">while</span> (!(UART_SR &amp; (<span class="number">1</span> &lt;&lt; UART_TC)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> uart_read() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!(UART_SR &amp; (<span class="number">1</span> &lt;&lt; UART_RXNE)));</span><br><span class="line">    <span class="keyword">return</span> UART_DR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redirecting <code>stdout</code> is easy with SDCC.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    uart_write(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we’re all set and we can use <code>printf()</code> for debugging.</p><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>Next, we implement SPI master. SPI is quite an easy peripheral and is usually implemented as a simple shift-register in hardware. We need to define only 4 registers to start working with SPI.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPI */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_CR1     _SFR_(0x200)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPE         6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BR0         3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSTR        2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_CR2     _SFR_(0x201)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSM         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSI         0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_SR      _SFR_(0x203)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSY         7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TXE         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RXNE        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DR      _SFR_(0x204)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Chip select */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CS_PIN      4</span></span><br></pre></td></tr></table></figure><p>Let’s implement initialization and read&#x2F;write functions. Reading from SPI is achieved by writing a dummy byte, so we’ll hardcode <code>SPI_write(0xFF)</code> inside our <code>SPI_read()</code> function. Chip select pin will be managed in software.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SPI pinout:</span></span><br><span class="line"><span class="comment"> * SCK  -&gt; PC5</span></span><br><span class="line"><span class="comment"> * MOSI -&gt; PC6</span></span><br><span class="line"><span class="comment"> * MISO -&gt; PC7</span></span><br><span class="line"><span class="comment"> * CS   -&gt; PC4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Initialize CS pin */</span></span><br><span class="line">    PC_DDR |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">    PC_CR1 |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">    PC_ODR |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize SPI master at 500kHz  */</span></span><br><span class="line">    SPI_CR2 = (<span class="number">1</span> &lt;&lt; SSM) | (<span class="number">1</span> &lt;&lt; SSI);</span><br><span class="line">    SPI_CR1 = (<span class="number">1</span> &lt;&lt; MSTR) | (<span class="number">1</span> &lt;&lt; SPE) | (<span class="number">1</span> &lt;&lt; BR0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI_write</span><span class="params">(<span class="keyword">uint8_t</span> data)</span> </span>&#123;</span><br><span class="line">    SPI_DR = data;</span><br><span class="line">    <span class="keyword">while</span> (!(SPI_SR &amp; (<span class="number">1</span> &lt;&lt; TXE)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> SPI_read() &#123;</span><br><span class="line">    SPI_write(<span class="number">0xFF</span>);</span><br><span class="line">    <span class="keyword">while</span> (!(SPI_SR &amp; (<span class="number">1</span> &lt;&lt; RXNE)));</span><br><span class="line">    <span class="keyword">return</span> SPI_DR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chip_select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PC_ODR &amp;= ~(<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chip_deselect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PC_ODR |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To test our implementation I’ve written a simple loop that transmits some data.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SPI_init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        chip_select();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0xAA</span>; i &lt; <span class="number">0xFA</span>; i += <span class="number">0x10</span>)</span><br><span class="line">            SPI_write(i);</span><br><span class="line">        chip_deselect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s hook up the logic analyzer and have a look.</p><img src="/blog/bare-metal-programming-stm8/spi_master.png" alt="SPI transmission" title="SPI transmission"><p>Hmm.. something is wrong. It seems that we release chip select too early and the last byte will not be received by a slave device. This can only occur if the SPI peripheral didn’t have enough time to finish transmitting before we released CS pin.</p><p>That wasn’t supposed to happen - we are polling for <code>TXE</code> bit, aren’t we? Well, the problem is that <code>TXE</code> only indicates that Tx buffer is empty. It doesn’t tell us that all the bits were shifted out by the shift register. So in order to properly end the transmission we have to check for <code>BSY</code> flag, which tells us whether or not SPI has finished an operation. Let’s modify our <code>chip_deselect()</code> function to take that into account.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chip_deselect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((SPI_SR &amp; (<span class="number">1</span> &lt;&lt; BSY)));</span><br><span class="line">    PC_ODR |= (<span class="number">1</span> &lt;&lt; CS_PIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Final output.</p><img src="/blog/bare-metal-programming-stm8/spi_master_fixed.png" alt="SPI fixed" title="SPI fixed"><p>Our final test is the good old “Nokia 5110” LCD. Complete source is on <a href="https://github.com/lujji/stm8-bare-min/tree/master/examples/SPI_LCD">github</a>.</p><img src="/blog/bare-metal-programming-stm8/nokia_lcd.jpg" alt="Nokia LCD" title="Nokia LCD"><h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><p>Now let’s get onto something more serious. I2C usually requires a bit more work to get it up and running comparing to SPI and UART. I2C has a lot of associated registers, so I will no longer list them from this point. You can find a header with register definitions <a href="https://github.com/lujji/stm8-bare-min/blob/master/stm8/stm8s.h">here</a>.</p><p>Let’s take a look at what the reference manual says about receive and transmit operations.</p><img src="/blog/bare-metal-programming-stm8/i2c.svg" alt="I2C transmit and receive modes" title="I2C transmit and receive modes"><p>That does seem quite complicated: a lot of events are generated during communication. However, we don’t have to explicitly take care of every single event in order to have a working communication - some of the events are automatically cleared by hardware and some may just be ignored and left unattended. We’ll go with the easiest implementation.</p><p>We start by implementing initialization and IO functions. We also need dedicated functions to generate start and stop conditions.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I2C pinout:</span></span><br><span class="line"><span class="comment"> * SCL -&gt; PB4</span></span><br><span class="line"><span class="comment"> * SDA -&gt; PB5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    I2C_FREQR = (<span class="number">1</span> &lt;&lt; I2C_FREQR_FREQ1);</span><br><span class="line">    I2C_CCRL = <span class="number">0x0A</span>; <span class="comment">// 100kHz</span></span><br><span class="line">    I2C_OARH = (<span class="number">1</span> &lt;&lt; I2C_OARH_ADDMODE); <span class="comment">// 7-bit addressing</span></span><br><span class="line">    I2C_CR1 = (<span class="number">1</span> &lt;&lt; I2C_CR1_PE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_START);</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_SB)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_STOP);</span><br><span class="line">    <span class="keyword">while</span> (I2C_SR3 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR3_MSL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_write</span><span class="params">(<span class="keyword">uint8_t</span> data)</span> </span>&#123;</span><br><span class="line">    I2C_DR = data;</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_TXE)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> i2c_read(<span class="keyword">uint8_t</span> ack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ack)</span><br><span class="line">        I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        I2C_CR2 &amp;= ~(<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_RXNE)));</span><br><span class="line">    <span class="keyword">return</span> I2C_DR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>According to the reference manual, writing slave address is a special case so we can’t simply use <code>i2c_write()</code> to do that. We need a dedicated function for this purpose.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_write_addr</span><span class="params">(<span class="keyword">uint8_t</span> addr)</span> </span>&#123;</span><br><span class="line">    I2C_DR = addr;</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_ADDR)));</span><br><span class="line">    (<span class="keyword">void</span>) I2C_SR3; <span class="comment">// clear EV6</span></span><br><span class="line">    I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference manual says we are supposed to to handle EV6 event after writing slave address: <em>“EV6: ADDR&#x3D;1, cleared by reading SR1 register followed by reading SR3”</em>. After polling for <code>ADDR</code> bit we simply read <code>SR3</code> register. I’m not sure why this is required, probably to check for BUS_BUSY, but that seemed a bit pointless so we cheated a little.</p><p>Now, let’s test our library with an HMC5883L magnetometer. First we define R&#x2F;W flags and some magnetometer related stuff:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_READ            0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_WRITE           0x00</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HMC5883_ADDR        (0x1E <span class="meta-string">&lt;&lt; 1)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_CR_A        0x00</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_CR_B        0x01</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_MODE        0x02</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_DATA_OUT    0x03</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define HMC5883_ID_REG_A    0x0A</span></span></span><br></pre></td></tr></table></figure><p>We’ll implement a simple function that reads the device Id and sends it over UART.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmc5883_get_id</span><span class="params">(<span class="keyword">uint8_t</span> *id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Tell device we want to read ID_REG_A */</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_write_addr(HMC5883_ADDR + I2C_WRITE);</span><br><span class="line">    i2c_write(HMC5883_ID_REG_A);</span><br><span class="line">    i2c_stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read ID bytes */</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_write_addr(HMC5883_ADDR + I2C_READ);</span><br><span class="line">    id[<span class="number">0</span>] = i2c_read(<span class="number">1</span>);</span><br><span class="line">    id[<span class="number">1</span>] = i2c_read(<span class="number">1</span>);</span><br><span class="line">    id[<span class="number">2</span>] = i2c_read(<span class="number">0</span>);</span><br><span class="line">    i2c_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> id[<span class="number">3</span>];</span><br><span class="line">    uart_init();</span><br><span class="line">    i2c_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hmc5883_get_id(id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Device ID: %c%c%c\n&quot;</span>, id[<span class="number">0</span>], id[<span class="number">1</span>], id[<span class="number">2</span>]);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Device ID: H43</span><br></pre></td></tr></table></figure><p>All seems to work fine, but let’s take a look at the logic analyzer just to make sure.</p><img src="/blog/bare-metal-programming-stm8/i2c_screenshot.png" alt="I2C receiver (broken)" title="I2C receiver (broken)"><p>Hmm.. we do receive correct bytes, but what’s the deal with that 0xFF received right after the NACK? It seems that something is wrong with our code. Time to RTFM.</p><h3 id="The-Proper-Way"><a href="#The-Proper-Way" class="headerlink" title="The Proper Way"></a>The Proper Way</h3><p>So the first problem is how we generate STOP condition. According to the documentation, we are supposed to generate STOP <em>before</em> reading the last byte. I changed the code but it didn’t fix the problem. The real problem was that I was porting the magnetometer driver which I wrote for a different microcontroller, so I <em>expected</em> the I2C peripheral to work in a certain way. Well, I was wrong.</p><p>The <code>i2c_read()</code> function is supposed to receive only 1 byte of data. It turns out there are 3 different scenarios for N&#x3D;1, N&#x3D;2 and N&gt;2, where N is the number of received bytes. We can’t simply use the function for N&#x3D;1 to read more than a single byte. That means we need separate functions to handle each case! I wonder how many logic gates were dedicated to implement I2C peripheral on this MCU… <em>(Note: I2C implementation on STM32F1xx series is actually identical to STM8.)</em></p><p>Looking at the reference manual I figured that we could possibly combine N&#x3D;2 and N&gt;2 cases and handle them with a single function. Below are proper implementations of I2C receive functions.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> i2c_read() &#123;</span><br><span class="line">    I2C_CR2 &amp;= ~(<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">    i2c_stop();</span><br><span class="line">    <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_RXNE)));</span><br><span class="line">    <span class="keyword">return</span> I2C_DR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_read_buf</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        I2C_CR2 |= (<span class="number">1</span> &lt;&lt; I2C_CR2_ACK);</span><br><span class="line">        <span class="keyword">while</span> (!(I2C_SR1 &amp; (<span class="number">1</span> &lt;&lt; I2C_SR1_RXNE)));</span><br><span class="line">        *(buf++) = I2C_DR;</span><br><span class="line">    &#125;</span><br><span class="line">    *buf = i2c_read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now let’s update our code for reading device Id.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmc5883_get_id</span><span class="params">(<span class="keyword">uint8_t</span> *id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Tell device we want to read ID_REG_A */</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_write_addr(HMC5883_ADDR + I2C_WRITE);</span><br><span class="line">    i2c_write(HMC5883_ID_REG_A);</span><br><span class="line">    i2c_stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read ID bytes */</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_write_addr(HMC5883_ADDR + I2C_READ);</span><br><span class="line">    i2c_read_buf(id, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that our <code>i2c_read_buf()</code> function generates STOP so we no longer have to call <code>i2c_stop()</code> manually. Let’s take a look at the logic analyzer now.</p><img src="/blog/bare-metal-programming-stm8/i2c_fixed_screenshot.png" alt="I2C fixed" title="I2C fixed"><p>Great, no 0xFF at the end! Now we’re ready to move onto something different.</p><h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><p>Nothing exciting about the ADC on STM8: 10-bit resolution, single and continuous conversion modes, configurable prescaler.. all the usual boring stuff. There is also a data buffer that can hold a number of ADC samples, which is rather convenient.</p><p>The default <code>printf()</code> implementation provided by SDCC does not support floats. To enable floating point output, <code>printf_large.c</code> needs to be recompiled with <code>-DUSE_FLOATS=1</code> option. For this example we are going to cheat and print the results in millivolts instead. Without further ado, let’s write some code for single ADC conversion.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V_REF 3.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> ADC_read() &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> adcH, adcL;</span><br><span class="line">    ADC1_CR1 |= (<span class="number">1</span> &lt;&lt; ADC1_CR1_ADON);</span><br><span class="line">    <span class="keyword">while</span> (!(ADC1_CSR &amp; (<span class="number">1</span> &lt;&lt; ADC1_CSR_EOC)));</span><br><span class="line">    adcL = ADC1_DRL;</span><br><span class="line">    adcH = ADC1_DRH;</span><br><span class="line">    ADC1_CSR &amp;= ~(<span class="number">1</span> &lt;&lt; ADC1_CSR_EOC); <span class="comment">// Clear EOC flag</span></span><br><span class="line">    <span class="keyword">return</span> (adcL | (adcH &lt;&lt; <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Configure ADC channel 4 (PD3)  */</span></span><br><span class="line">    ADC1_CSR |= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* Right-align data */</span></span><br><span class="line">    ADC1_CR2 |= (<span class="number">1</span> &lt;&lt; ADC1_CR2_ALIGN);</span><br><span class="line">    <span class="comment">/* Wake ADC from power down */</span></span><br><span class="line">    ADC1_CR1 |= <span class="number">1</span> &lt;&lt; ADC1_CR1_ADON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ADC_init();</span><br><span class="line">    uart_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> val = ADC_read();</span><br><span class="line">        <span class="keyword">float</span> voltage = (V_REF / <span class="number">1024.0</span>) * val * <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Channel4: %d mV\n&quot;</span>, (<span class="keyword">uint16_t</span>) voltage);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pretty straight forward. Note that <code>EOC</code> flag has to be manually cleared by software.</p><p>A few things that should be taken into account when working with ADC:</p><ul><li>The order in which <code>DRL</code> and <code>DRH</code> registers are accessed depends on data alignment.</li><li>ADC has no internal voltage reference. STM8S003 does not have an external Vref pin, so it is tied to Vcc internally, which means that your supply voltage has to be spot-on for any serious measurements.</li><li>Data buffer registers have no internal locking. ST provides an assembly snippet in the datasheet for reading buffer registers.</li></ul><h3 id="Timers-and-interrupts"><a href="#Timers-and-interrupts" class="headerlink" title="Timers and interrupts"></a>Timers and interrupts</h3><p>You can’t get far without using timers and interrupts, which is what this last section will cover. STM8S003 has 16-bit ‘advanced control’ as well as 8-bit general-purpose timers. TIM1 is a really complicated peripheral with 32 dedicated registers, and covering it’s functionality would probably require a few extra articles. For this article, we’ll use TIM4 which is good enough for basic applications.</p><p>There isn’t much to tweak inside TIM4: it contains an 8-bit auto-reload up counter, 3-bit prescaler and an option to generate interrupt on counter overflow.</p><p>The prescaler divides counter clock frequency by a power of 2 from 1 to 128 depending on <code>PSCR</code> registers:</p><img src="/blog/bare-metal-programming-stm8/timer_prescaler.svg" alt="""" title=""""><p>In this example we are going to toggle a pin each time the counter matches value in the <code>ARR</code> register. The frequency of the waveform generated by our IO pin is calculated as follows:</p><img src="/blog/bare-metal-programming-stm8/timer_f_io.svg" alt="""" title=""""><p>To achieve a frequency of 100Hz <code>ARR</code> has to be set to 77, given that our clock frequency is 2MHz. We need to enable Update Interrupt for <code>TIM4</code>, but before that interrupts must be enabled globally by executing <code>rim</code> instruction.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Enable interrupts */</span></span><br><span class="line">    <span class="keyword">__asm__</span>(<span class="string">&quot;rim&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set PD3 as output */</span></span><br><span class="line">    PD_DDR |= (<span class="number">1</span> &lt;&lt; OUTPUT_PIN);</span><br><span class="line">    PD_CR1 |= (<span class="number">1</span> &lt;&lt; OUTPUT_PIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prescaler = 128 */</span></span><br><span class="line">    TIM4_PSCR = <span class="number">0b00000111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Period = 5ms */</span></span><br><span class="line">    TIM4_ARR = <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line">    TIM4_IER |= (<span class="number">1</span> &lt;&lt; TIM4_IER_UIE); <span class="comment">// Enable Update Interrupt</span></span><br><span class="line">    TIM4_CR1 |= (<span class="number">1</span> &lt;&lt; TIM4_CR1_CEN); <span class="comment">// Enable TIM4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Loop forever */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Now, when I said that we’re going to implement everything from scratch, I wasn’t completely honest. We’re still using some start-up code which initializes the stack and interrupt vector table. If you look at the listing you can see that SDCC has generated the interrupt table for us:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">000000 82v00u00u00             37         int s_GSINIT ;reset</span><br><span class="line">000004 82 00 00 00             38         int 0x0000 ;trap</span><br><span class="line">000008 82 00 00 00             39         int 0x0000 ;int0</span><br><span class="line">...</span><br><span class="line">00007C 82 00 00 00             68         int 0x0000 ;int29</span><br></pre></td></tr></table></figure><p>Registering an interrupt handler is easy with SDCC: there is a special attribute <code>_interrupt()</code> which takes interrupt number as a parameter. Section 7 (‘Interrupt vector mapping’) of the datasheet describes which IRQ number corresponds to which peripheral. For TIM4 it is 23. Our interrupt handler will look like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIM4_ISR 23</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_isr</span><span class="params">(<span class="keyword">void</span>)</span> __<span class="title">interrupt</span><span class="params">(TIM4_ISR)</span> </span>&#123;</span><br><span class="line">    PD_ODR ^= (<span class="number">1</span> &lt;&lt; OUTPUT_PIN);</span><br><span class="line">    TIM4_SR &amp;= ~(<span class="number">1</span> &lt;&lt; UIF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p>We have enough building blocks - now it’s time to put them together into some ‘real-world’ application. For this demo I picked up <a href="http://www.nxp.com/assets/documents/data/en/data-sheets/MMA8452Q.pdf">MMA8452</a> 3-axis I2C accelerometer and a standard <a href="https://www.sparkfun.com/datasheets/LCD/HD44780.pdf">HD44780</a> 1602 LCD, which is extremely popular among electronics enthusiasts for some reason.</p><p>The demo application will calculate inclination angle based on accelerometer readings and output it to the LCD. Calculating inclination angle will require some trigonometry and floating point arithmetic, which will consume a good amount of resources. Despite the floating point operations being quite slow, STM8 managed this task decently.</p><img src="/blog/bare-metal-programming-stm8/demo.jpg" alt="Demo" title="Demo"><p>You might have noticed the lack of contrast adjustment potentiometer. The LCD module that I’m using is rated for 5V, however my setup uses 3.3V supply. I couldn’t be bothered with a separate supply for the display, so I cheated: the LCD is initialized in 1-line mode, which results in 1&#x2F;8 duty cycle, and <code>Vo</code> pin is tied to ground.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>STM8 is nice and cheap, but it is really hard to justify using this microcontroller, especially given the fact that price difference between STM8 and low-end Cortex-M0 devices like STM32F03 is negligible. The biggest downside for me was lack of GCC support. Despite SDCC being a reasonably good compiler, it does not fully support C99 and C11 standards, which means that I have to refactor most of my existing code to make it compatible. Code optimization isn’t great either, which is a shame, since most STM8 microcontrollers don’t have a lot of flash to spare.</p><p>As always, code is available on <a href="https://github.com/lujji/stm8-bare-min">github</a>.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;This article will cover developing for STM8 series of microcontrolles completely from scratch, without using any vendor-supplied libraries.&lt;/p&gt;</summary>
    
    
    
    
    <category term="bare-metal" scheme="http://lujji.github.io/blog/tags/bare-metal/"/>
    
    <category term="sdcc" scheme="http://lujji.github.io/blog/tags/sdcc/"/>
    
    <category term="stm8" scheme="http://lujji.github.io/blog/tags/stm8/"/>
    
  </entry>
  
  <entry>
    <title>Installing Black Magic via ST-Link bootloader</title>
    <link href="http://lujji.github.io/blog/installing-blackmagic-via-stlink-bootloader/"/>
    <id>http://lujji.github.io/blog/installing-blackmagic-via-stlink-bootloader/</id>
    <published>2017-02-15T22:30:54.000Z</published>
    <updated>2017-03-18T21:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>ST-Link hardware has become a host for various debuggers, including J-Link and Versaloon (which no longer seems to be maintained). To be honest, I was so spoiled by J-Link that I never had the necessity to try different debugging hardware. Only recently I have discovered the <a href="https://github.com/blacksphere/blackmagic">Black Magic Probe</a> which, according to Hackaday, is the <a href="http://hackaday.com/2016/12/02/black-magic-probe-the-best-arm-jtag-debugger">best ARM JTAG debugger</a>.</p><span id="more"></span><p>Installing BMP firmware on ST-Link presents a few obstacles: you need a second programmer to flash the on-board ST-Link on Discovery boards and clones from China require some soldering. The sad part is that in both cases you loose the original firmware.</p><p>The purpose of this article is to achieve the following goals:</p><ol><li>Port BMP firmware to native ST-Link bootloader</li><li>Make the firmware available for both ST-Link v2 and v2-1</li></ol><h2 id="Changing-application-start-address"><a href="#Changing-application-start-address" class="headerlink" title="Changing application start address"></a>Changing application start address</h2><p>Native ST-Link bootloader loads the firmware at address 0x08004000. Black Magic Probe bootloader is more compact and loads the firmware at offset 0x2000, which allows extra 8k of flash to be used by the firmware. In order to make the program compatible with ST-Link bootloader, we need to adjust the start address first.</p><p>BMP firmware is built on top of libopencm3 and is well organized. Changing the application start address is a bit tricky though, since it’s hard-coded in many places. First of all, we alter the linker script and set ROM length to 128k. We also need to set <code>SCB_VTOR</code> to <code>0x4000</code> in stlink&#x2F;platform.c so that the interrupt vector table is relocated in the right place. Another issue arises due to the fact that ST-Link bootloader leaves USB peripheral initialized when jumping to the main application. We need the host to re-enumerate our device, hence we reset the USB peripheral and pull <code>D+</code> pin low:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">platform_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Re-enumerate USB device */</span></span><br><span class="line">    rcc_periph_reset_pulse(RST_USB);</span><br><span class="line">    rcc_periph_clock_enable(RCC_USB);</span><br><span class="line">    rcc_periph_clock_enable(RCC_GPIOA);</span><br><span class="line">    gpio_clear(GPIOA, GPIO12);</span><br><span class="line">    gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_2_MHZ,</span><br><span class="line">            GPIO_CNF_OUTPUT_OPENDRAIN, GPIO12);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we are ready to compile the firmware.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make PROBE_HOST=stlink</span><br></pre></td></tr></table></figure><p>Finally, we need to encrypt the firmware with <a href="https://github.com/lujji/st-decrypt">st-derypt</a> utility and replace the binary inside the <a href="http://www.st.com/en/embedded-software/stsw-link007.html">updater</a> archive. Here’s a quick bash script that does all the steps for you:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># path to unpacked STLinkUpgrade.jar</span></span><br><span class="line">DEST=<span class="string">&quot;/home/lujji/stsw-link007/AllPlatforms/STLinkUpgrade&quot;</span></span><br><span class="line"><span class="comment"># input binary</span></span><br><span class="line">INPUT_FILE=<span class="string">&quot;/home/lujji/blackmagic/src/blackmagic.bin&quot;</span></span><br><span class="line"><span class="comment"># st-decrypt utility</span></span><br><span class="line">ST_DECRYPT=<span class="string">&quot;java -jar /home/lujji/st_decrypt/st_decrypt.jar&quot;</span></span><br><span class="line"></span><br><span class="line">$(ST_DECRYPT) -k <span class="string">&quot;best performance&quot;</span> -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -o f2_x.bin --encrypt</span><br><span class="line"><span class="built_in">cp</span> f2_x.bin <span class="string">&quot;<span class="variable">$DEST</span>/com/st/stlinkupgrade/core/f2_1.bin&quot;</span></span><br><span class="line"><span class="built_in">cp</span> f2_x.bin <span class="string">&quot;<span class="variable">$DEST</span>/com/st/stlinkupgrade/core/f2_2.bin&quot;</span></span><br><span class="line"><span class="built_in">cp</span> f2_x.bin <span class="string">&quot;<span class="variable">$DEST</span>/com/st/stlinkupgrade/core/f2_3.bin&quot;</span></span><br><span class="line"><span class="built_in">cp</span> f2_x.bin <span class="string">&quot;<span class="variable">$DEST</span>/com/st/stlinkupgrade/core/f2_4.bin&quot;</span></span><br><span class="line"><span class="built_in">mv</span> f2_x.bin <span class="string">&quot;<span class="variable">$DEST</span>/com/st/stlinkupgrade/core/f2_5.bin&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$DEST</span>&quot;</span></span><br><span class="line">zip -qr ../updater.jar .</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">java -jar updater.jar</span><br></pre></td></tr></table></figure><p>From this point if we use ST-Link v2-1 with a 128k microcontroller, we’re good to go. However, the resulting binary is too large to fit inside a 64k part. Initially I was trying to get the size down by compiling with various optimizations enabled, but I just couldn’t get the binary small enough.</p><p>Luckily, <code>Paul Fertser</code> from OpenOCD project reminded me that most F103C8 parts usually have twice as much flash as they should. It’s common practice among silicon manufacturers: high-end parts that did not fully pass electrical testing and quality control are sold as lower end parts. In fact, ST-Link clones from China take full advantage of this ‘feature’: most 3$ dongles are using STM32F101 which doesn’t even have USB peripheral.</p><p>Knowing all that, let’s try flashing ST-Link v2 with our firmware.</p><img src="/blog/installing-blackmagic-via-stlink-bootloader/firmware-too-big.png" alt="Fail" title="Fail"><h2 id="Patching-the-updater"><a href="#Patching-the-updater" class="headerlink" title="Patching the updater"></a>Patching the updater</h2><p>I couldn’t just write a post about compiling BMP sources, so I decided to describe patching Java bytecode in more detail. I’m pretty sure there are various tools out there that would achieve the same result much easier, but I’m going to stick with standard utilities from Java Development Kit for the most part.</p><p>A <code>.jar</code> package is simply a zip archive which contains a manifest and a bunch of other stuff. Compiled Java bytecode is located inside <code>.class</code> files. It’s kind of like assembly but for the virtual machine. To decompile a binary we use <code>javap</code> utility from JDK.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c ./stlinkupgrade/core/c.class &gt; c_bytecode.java</span><br></pre></td></tr></table></figure><p>Doing a quick search reveals the text string we’re interested in:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">498: isub                              // 0x64</span><br><span class="line">499: i2l                               // 0x85</span><br><span class="line">500: lcmp                              // 0x94</span><br><span class="line">501: ifle          566                 // 0x9E</span><br><span class="line">...</span><br><span class="line">530: new           #70                 // class java/lang/StringBuilder</span><br><span class="line">533: dup</span><br><span class="line">534: ldc           #38                 // String The up-to-date firmware is too big for this board</span><br></pre></td></tr></table></figure><p>I’ve written hex representation of some of the opcodes on the right, see <a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">bytecode instructions list</a> for more details.<br>Now if we search for pattern  <code>64 85 94 9E</code> and patch <code>ifle</code> (0x9E) -&gt; <code>ifne</code> (0x9A), we shall get past the flash size check.</p><p>That’s not enough though. If we update the firmware now, it will be corrupt (although it will work to some extent). To figure out what’s going on let’s take a look at one of the firmware dumps I’ve taken previously:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000ffc0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................</span><br><span class="line">0x0000ffd0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................</span><br><span class="line">0x0000ffe0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................</span><br><span class="line">0x0000fff0: ff ff ff ff ff ff ff ff ff ff ff ff d3 27 00 a5  .............&#x27;..</span><br></pre></td></tr></table></figure><p>As you can see there, is some sort of ‘EOF’ record written at address 0xFFFC. Luckily, it is written by the updater and not the bootloader itself. This was too fiddly to analyze in plain bytecode, so I used <a href="https://bitbucket.org/mstrobel/procyon/downloads">Procyon decompiler</a> to produce readable code from compiled binary. Going through the same file (<code>core/c.class</code>) reveals the following line:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">n5</span> <span class="operator">=</span> <span class="number">134217728</span> + (<span class="built_in">this</span>.p &lt;&lt; <span class="number">10</span>) - <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>134217728 is 0x8000000, which is flash memory base address.<br>We can assume that <code>this.p</code> field is the flash size: 134217728 + (64 &lt;&lt; 10) - 4 &#x3D; 0x800FFFC. This is exactly where ‘EOF’ is written. Our objective is to make the updater always think we have 128k of flash. Now back to the bytecode.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">661: ldc           #2                  // int 134217728</span><br><span class="line">663: aload_0                           // 2a            -&gt; 00 11</span><br><span class="line">664: getfield      #142                // b4 Field p:I  -&gt; 00 80</span><br><span class="line"></span><br><span class="line">667: bipush        10                  // 10 0a</span><br><span class="line">669: ishl                              // 78</span><br><span class="line">670: iadd                              // 60</span><br><span class="line">671: iconst_4</span><br><span class="line">672: isub</span><br></pre></td></tr></table></figure><p>Instruction <code>getfield #142</code> needs to be patched into <code>sipush 128</code>. NOP <code>aload_0</code> to keep the stack consistent. We search for pattern <code>10 0A 78 60</code> and replace <em>preceding</em> 4 bytes with <code>00 11 00 80</code>.</p><p>That was plain straight-forward patching. But it works. If we wanted to do things the <em>right</em> way, then we should have altered <code>GetDeviceInfo()</code> function and make it always think that our device has 128k of flash.</p><h2 id="Exiting-DFU-mode"><a href="#Exiting-DFU-mode" class="headerlink" title="Exiting DFU mode"></a>Exiting DFU mode</h2><p>There is a slight issue: each time you plug in ST-Link it starts in DFU mode. This could be quite annoying when using Black Magic Probe firmware.</p><p>The easiest workaround is to execute any program that issues <code>dfu_exit()</code> once the device is attached. We can deal with it by creating a <code>udev</code> rule or each time manually executing a command like reading chip ID, flash, etc.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/udev/rules.d/99-stlink.rules</span></span><br><span class="line">ACTION==<span class="string">&quot;add&quot;</span>, SUBSYSTEM==<span class="string">&quot;usb&quot;</span>, \</span><br><span class="line">               ATTR&#123;idVendor&#125;==<span class="string">&quot;0483&quot;</span>, ATTR&#123;idProduct&#125;==<span class="string">&quot;3748&quot;</span>, \</span><br><span class="line">               MODE=<span class="string">&quot;0666&quot;</span>, RUN+=<span class="string">&quot;/usr/bin/st-info --probe&quot;</span></span><br></pre></td></tr></table></figure><p>If everything was done properly, you should get similar dmesg output:</p><img src="/blog/installing-blackmagic-via-stlink-bootloader/dmesg_blackmagic.png" alt="""" title=""""><p>I used <code>st-info</code> from <a href="https://github.com/texane/stlink">texane&#x2F;stlink</a>. Make sure you provide the full path to the utility in the udev rule. If you ever need to enter DFU mode again, just remove the <code>RUN</code> part and reload udev rules.</p><h4 id="The-Segger-way"><a href="#The-Segger-way" class="headerlink" title="The Segger way"></a>The Segger way</h4><p>You might be wondering how Segger deals with this issue in their J-Link firmware. The answer is quite simple: <strong>they patch the bootloader</strong>. I kid you not, they literary erase a bootloader page at address <code>0x2400</code> and insert some code that branches to <code>0x4000</code>. Basically, this renders the bootloader useless and relies on the firmware and ‘reflash’ utility to recover the erased page when needed.  At least it’s good to know that I’m not the only one patching ST’s bootloader..</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We have a way of installing BMP firmware without destroying ST-Link bootloader - mission accomplished. That being said, patching the updater utility is definitely not the most elegant solution to the problem. ST’s DFU protocol could be easily reverse-engineered, but I couldn’t invest more time in it. Besides, installing the firmware on ST-Link v2-1 does not require any patching and should be pretty straight-forward. Overall, I think it’s a nice way of trying out Black Magic firmware.</p><p>As always, code is on <a href="https://github.com/lujji/blackmagic/tree/stlink-bootloader">github</a>, including precompiled firmware binary.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ST-Link hardware has become a host for various debuggers, including J-Link and Versaloon (which no longer seems to be maintained). To be honest, I was so spoiled by J-Link that I never had the necessity to try different debugging hardware. Only recently I have discovered the &lt;a href=&quot;https://github.com/blacksphere/blackmagic&quot;&gt;Black Magic Probe&lt;/a&gt; which, according to Hackaday, is the &lt;a href=&quot;http://hackaday.com/2016/12/02/black-magic-probe-the-best-arm-jtag-debugger&quot;&gt;best ARM JTAG debugger&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
    <category term="st-link" scheme="http://lujji.github.io/blog/tags/st-link/"/>
    
    <category term="blackmagic" scheme="http://lujji.github.io/blog/tags/blackmagic/"/>
    
    <category term="reverse-engineering" scheme="http://lujji.github.io/blog/tags/reverse-engineering/"/>
    
    <category term="java-bytecode" scheme="http://lujji.github.io/blog/tags/java-bytecode/"/>
    
  </entry>
  
  <entry>
    <title>HTTP server with WebSockets on ESP8266</title>
    <link href="http://lujji.github.io/blog/esp-httpd/"/>
    <id>http://lujji.github.io/blog/esp-httpd/</id>
    <published>2017-01-30T18:11:00.000Z</published>
    <updated>2017-02-28T23:36:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>This article will cover implementing a basic HTTP server on top of LwIP for ESP8266 and dive into the implementation of WebSockets.</p><span id="more"></span><hr><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>ESP8266 is an extremely popular device. Chances are, at some point you even bought a few modules for some “future project”. That’s exactly what I did, and for a long time I didn’t find any application for this device.</p><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents:"></a>Contents:</h2><ul><li><a href="#The-Hardware">The Hardware</a></li><li><a href="#Simple-HTTP-server">Simple HTTP server</a></li><li><a href="#WebSockets">WebSockets</a><br>– <a href="#Opening-handshake">Opening handshake</a><br>– <a href="#Transmitting-data">Transmitting data</a><br>– <a href="#Closing-connection">Closing connection</a></li><li><a href="#Demo">Demo</a></li></ul><h2 id="The-Hardware"><a href="#The-Hardware" class="headerlink" title="The Hardware"></a>The Hardware</h2><p>At first glance, ESP8266 looks quite attractive: 32-bit processor, decent amount of RAM, up to 4MB external flash for user code. But once you dive into the specifics of the device, you immediately start facing it’s problems: the documentation is rather scarce, power consumption is about 80mA during normal operation, which is a problem for battery-powered applications, and even though you can have a large external flash, the ESP8266 can only map 1 megabyte of it into execution space. The rest of the flash may be used for firmware updates and data storage. Overall, the device itself does not instill a lot of confidence. But hey.. it’s cheap.</p><img src="/blog/esp-httpd/hardware.jpg" alt="ESP8266" title="ESP8266"><p>To get the module up and running we need a 3V3 supply rail and a UART-USB converter for programming. Apart from Rx&#x2F;Tx the following lines need to be connected from the serial cable to the module:</p><p><code>RTS</code> -&gt; <code>Reset</code><br><code>DTR</code> -&gt; <code>Boot/GPIO0</code><br><code>3V3</code> -&gt; <code>CH_PD</code></p><p>ESP-12E modules already have a pull-up resistor on reset line. Optionally, a pull-up should be installed on <code>GPIO0</code>.</p><p>As for the software, there are two versions of SDK from Espressif - one of them is based on FreeRTOS and the other one is based on callbacks. It seems that most development occurs around the non-RTOS version of SDK. At the moment of writing this post, the latest FreeRTOS version provided by Espressif SDK seems to be 7.5.2, while the latest upstream version is 9.0.0. Luckily, <a href="https://github.com/SuperHouse/esp-open-rtos">esp-open-rtos</a> addresses this issue. It is a community-developed framework based on the latest version of FreeRTOS, which aims to provide open-source alternatives to the binary blobs of the Espressif SDK.</p><h2 id="Simple-HTTP-server"><a href="#Simple-HTTP-server" class="headerlink" title="Simple HTTP server"></a>Simple HTTP server</h2><p>To get a better understanding of how things work, let’s implement the most basic HTTP server. First we need to create a new task called <code>httpd_task</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate(&amp;httpd_task, <span class="string">&quot;http_server&quot;</span>, <span class="number">1024</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>We are going to use LwIP’s <code>netconn</code> API for our demo, <code>&lt;lwip/api.h&gt;</code> needs to be included.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">httpd_task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> netconn *client = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> netconn *nc = netconn_new(NETCONN_TCP);</span><br><span class="line">    <span class="keyword">if</span> (nc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to allocate socket\n&quot;</span>);</span><br><span class="line">        vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    netconn_bind(nc, IP_ADDR_ANY, <span class="number">80</span>);</span><br><span class="line">    netconn_listen(nc);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">err_t</span> err = netconn_accept(nc, &amp;client);</span><br><span class="line">        <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">            <span class="keyword">struct</span> netbuf *nb;</span><br><span class="line">            <span class="keyword">if</span> ((err = netconn_recv(client, &amp;nb)) == ERR_OK) &#123;</span><br><span class="line">                <span class="keyword">void</span> *data;</span><br><span class="line">                <span class="keyword">u16_t</span> len;</span><br><span class="line">                netbuf_data(nb, &amp;data, &amp;len);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Received data:\n%.*s\n&quot;</span>, len, (<span class="keyword">char</span>*) data);</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf),</span><br><span class="line">                        <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;Content-type: text/html\r\n\r\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;Test&quot;</span>);</span><br><span class="line">                netconn_write(client, buf, <span class="built_in">strlen</span>(buf), NETCONN_COPY);</span><br><span class="line">            &#125;</span><br><span class="line">            netbuf_delete(nb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Closing connection\n&quot;</span>);</span><br><span class="line">        netconn_close(client);</span><br><span class="line">        netconn_delete(client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code is pretty straight-forward: we create a new <code>netconn</code>, bind it to port 80 (which is used for HTTP) and start listening for incoming TCP connections. In the main loop of the task we call a blocking function <code>netconn_accept()</code>. Once the connection from client is accepted we log the request to console and generate a response. Response contains a minimal header that is enough for the browser to treat anything after <code>\r\n\r\n</code> as an HTML page.</p><img src="/blog/esp-httpd/http_test.png" alt="Hello, world" title="Hello, world"><p>When browser requests a page it sends a <code>GET</code> request, which looks like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 192.168.100.4</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>We’re only interested in the first line that contains the URI. To make things a bit more interesting we are going to extract the URI and switch the LED on the device when particular address is requested. We’ll also add some page content just for kicks.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">httpd_task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> netconn *client = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> netconn *nc = netconn_new(NETCONN_TCP);</span><br><span class="line">    <span class="keyword">if</span> (nc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to allocate socket.\n&quot;</span>);</span><br><span class="line">        vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    netconn_bind(nc, IP_ADDR_ANY, <span class="number">80</span>);</span><br><span class="line">    netconn_listen(nc);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *webpage = &#123;</span><br><span class="line">        <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">        <span class="string">&quot;Content-type: text/html\r\n\r\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Server&lt;/title&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;style&gt; div.main &#123;&quot;</span></span><br><span class="line">        <span class="string">&quot;font-family: Arial;&quot;</span></span><br><span class="line">        <span class="string">&quot;padding: 0.01em 16px;&quot;</span></span><br><span class="line">        <span class="string">&quot;box-shadow: 2px 2px 1px 1px #d2d2d2;&quot;</span></span><br><span class="line">        <span class="string">&quot;background-color: #f1f1f1;&#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;/style&gt;&lt;/head&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;body&gt;&lt;div class=&#x27;main&#x27;&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;h3&gt;HTTP Server&lt;/h3&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;p&gt;URL: %s&lt;/p&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;p&gt;Uptime: %d seconds&lt;/p&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;p&gt;Free heap: %d bytes&lt;/p&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;button onclick=\&quot;location.href=&#x27;/on&#x27;\&quot; type=&#x27;button&#x27;&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;LED On&lt;/button&gt;&lt;/p&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;button onclick=\&quot;location.href=&#x27;/off&#x27;\&quot; type=&#x27;button&#x27;&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;LED Off&lt;/button&gt;&lt;/p&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* disable LED */</span></span><br><span class="line">    gpio_enable(<span class="number">2</span>, GPIO_OUTPUT);</span><br><span class="line">    gpio_write(<span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">err_t</span> err = netconn_accept(nc, &amp;client);</span><br><span class="line">        <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">            <span class="keyword">struct</span> netbuf *nb;</span><br><span class="line">            <span class="keyword">if</span> ((err = netconn_recv(client, &amp;nb)) == ERR_OK) &#123;</span><br><span class="line">                <span class="keyword">void</span> *data;</span><br><span class="line">                <span class="keyword">u16_t</span> len;</span><br><span class="line">                netbuf_data(nb, &amp;data, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* check for a GET request */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(data, <span class="string">&quot;GET &quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">                    <span class="keyword">char</span> uri[<span class="number">16</span>];</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> max_uri_len = <span class="number">16</span>;</span><br><span class="line">                    <span class="keyword">char</span> *sp1, *sp2;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* extract URI */</span></span><br><span class="line">                    sp1 = data + <span class="number">4</span>;</span><br><span class="line">                    sp2 = <span class="built_in">memchr</span>(sp1, <span class="string">&#x27; &#x27;</span>, max_uri_len);</span><br><span class="line">                    <span class="keyword">int</span> len = sp2 - sp1;</span><br><span class="line">                    <span class="built_in">memcpy</span>(uri, sp1, len);</span><br><span class="line">                    uri[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;uri: %s\n&quot;</span>, uri);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(uri, <span class="string">&quot;/on&quot;</span>, max_uri_len))</span><br><span class="line">                        gpio_write(<span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(uri, <span class="string">&quot;/off&quot;</span>, max_uri_len))</span><br><span class="line">                        gpio_write(<span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), webpage,</span><br><span class="line">                            uri,</span><br><span class="line">                            xTaskGetTickCount() * portTICK_PERIOD_MS / <span class="number">1000</span>,</span><br><span class="line">                            (<span class="keyword">int</span>) xPortGetFreeHeapSize());</span><br><span class="line">                    netconn_write(client, buf, <span class="built_in">strlen</span>(buf), NETCONN_COPY);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            netbuf_delete(nb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Closing connection\n&quot;</span>);</span><br><span class="line">        netconn_close(client);</span><br><span class="line">        netconn_delete(client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we have a slightly more interactive server.</p><img src="/blog/esp-httpd/http_test2.png" alt="Simple HTTP server" title="Simple HTTP server"><p>In case your application needs to serve a simple web-page, this approach might just be good enough.</p><p>Although implementing an HTTP server from scratch could be a good exercise, I didn’t find it very exciting, so instead of reinventing the wheel I decided to find one that is round enough for my needs.</p><p>For my application I decided to use <a href="http://www.nongnu.org/lwip/2_0_0/group__httpd.html">httpd</a> from LwIP&#x2F;contrib. This server is based on callbacks, so it should work with RTOS and non-RTOS SDK.</p><h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><p>WebSocket is a protocol which allows full-duplex communication between client (like web-browser) and server. This means that we can send small messages back and forth for doing things like toggling pins and reading sensor data without having to refresh the web-page and transfer large amounts of HTTP data all the time. We’ll have to resort to HTTP only once for the opening handshake, after that all the communication is happening on the TCP layer. Everything we need to know in order to implement WebSocket protocol is described in <a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a>.</p><h3 id="Opening-handshake"><a href="#Opening-handshake" class="headerlink" title="Opening handshake"></a>Opening handshake</h3><p>Probably the hardest part. When client wants to open a WebSocket it sends a specific GET request:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br></pre></td></tr></table></figure><p>The server should generate the following response:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure><p>The procedure to generate <code>Sec-WebSocket-Accept</code> part is as follows:</p><ol><li>Take the <code>Sec-WebSocket-Key</code> part</li><li>Concatenate it with GUID which is “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”</li><li>Calculate SHA-1 hash of the resulting string</li><li>Encode the hash in base-64</li></ol><p>Let’s first define some necessary constants inside <code>httpd.c</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_HEADER[] = <span class="string">&quot;Upgrade: websocket\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_GUID[] = <span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_KEY[] = <span class="string">&quot;Sec-WebSocket-Key: &quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_RSP[] = <span class="string">&quot;HTTP/1.1 101 Switching Protocols\r\n&quot;</span> \</span><br><span class="line">                      <span class="string">&quot;Upgrade: websocket\r\n&quot;</span> \</span><br><span class="line">                      <span class="string">&quot;Connection: Upgrade\r\n&quot;</span> \</span><br><span class="line">                      <span class="string">&quot;Sec-WebSocket-Accept: %s\r\n\r\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>According to the HTTP specification, comparison of fields like <code>WS_HEADER</code> should be case-insensitive. Despite that, we’ll use standard <code>strnstr()</code> function, since most browsers follow the convention and generate requests as defined above.</p><p>We’ll need to alter <code>http_parse_request()</code> function to support opening handshake. In this context <code>data</code> is the incoming TCP buffer.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (strnstr(data, WS_HEADER, data_len)) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoded_key[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span> key[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> *key_start = strnstr(data, WS_KEY, data_len);</span><br><span class="line">    <span class="keyword">if</span> (key_start) &#123;</span><br><span class="line">        key_start += <span class="number">19</span>;</span><br><span class="line">        <span class="keyword">char</span> *key_end = strnstr(key_start, <span class="string">&quot;\r\n&quot;</span>, data_len);</span><br><span class="line">        <span class="keyword">if</span> (key_end) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (key_end - key_start);</span><br><span class="line">            <span class="keyword">if</span> (len + <span class="keyword">sizeof</span>(WS_GUID) &lt; <span class="keyword">sizeof</span>(key) &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* Concatenate key */</span></span><br><span class="line">                <span class="built_in">memcpy</span>(key, key_start, len);</span><br><span class="line">                strlcpy(&amp;key[len], WS_GUID, <span class="keyword">sizeof</span>(key));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Resulting key: %s\n&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Get SHA1 */</span></span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> sha1sum[<span class="number">20</span>];</span><br><span class="line">                mbedtls_sha1((<span class="keyword">unsigned</span> <span class="keyword">char</span> *) key, <span class="keyword">sizeof</span>(WS_GUID) + len - <span class="number">1</span>, sha1sum);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Base64 encode */</span></span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> olen;</span><br><span class="line">                mbedtls_base64_encode(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;olen, sha1sum, <span class="number">20</span>); <span class="comment">//get length</span></span><br><span class="line">                <span class="keyword">int</span> ok = mbedtls_base64_encode(encoded_key, <span class="keyword">sizeof</span>(encoded_key), &amp;olen, sha1sum, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ok == <span class="number">0</span>) &#123;</span><br><span class="line">                    hs-&gt;is_websocket = <span class="number">1</span>;</span><br><span class="line">                    encoded_key[olen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Base64 encoded: %s\n&quot;</span>, encoded_key);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Send response */</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">                    <span class="keyword">u16_t</span> len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), WS_RSP, encoded_key);</span><br><span class="line">                    http_write(pcb, buf, &amp;len, TCP_WRITE_FLAG_COPY);</span><br><span class="line">                    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Key overflow\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Malformed packet\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERR_ARG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Note: I’m using <code>sizeof(buf)</code> quite often to get the array length at compile-time. In this case it works as expected due to the fact that <code>buf</code> is always of char type. A more proper solution is to use <code>sizeof(buf)/sizeof(buf[0])</code> - this way we get the correct result regardless of the data type.</em></p><h3 id="Transmitting-data"><a href="#Transmitting-data" class="headerlink" title="Transmitting data"></a>Transmitting data</h3><p>On the client side opening a new WebSocket and listening for incoming messages is just a matter of few lines of javascript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Open new websocket and register callback */</span></span><br><span class="line">ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://192.168.54.29&quot;</span>);</span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123; <span class="title function_">onMessage</span>(evt) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onMessage</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(evt.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When server receives data from a client the payload is <em>always</em> masked (assuming that client’s implementation of the protocol is correct), therefore, we need to unmask the payload before passing it to the user callback. <a href="https://tools.ietf.org/html/rfc6455#page-33">Masking algorithm</a> is rather trivial.<br>The first byte of the payload contains an opcode. We’re only going to support text or binary modes and close request. We shall omit continuation frames to keep things simple.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> err_t <span class="title">websocket_parse</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="keyword">struct</span> pbuf *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data;</span><br><span class="line">    data = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*) p-&gt;payload;</span><br><span class="line">    <span class="keyword">u16_t</span> data_len = p-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">NULL</span> &amp;&amp; data_len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> opcode = data[<span class="number">0</span>] &amp; <span class="number">0x0F</span>;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x01</span>: <span class="comment">// text</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x02</span>: <span class="comment">// bin</span></span><br><span class="line">                <span class="keyword">if</span> (data_len &gt; <span class="number">6</span>) &#123;</span><br><span class="line">                    data_len -= <span class="number">6</span>;</span><br><span class="line">                    <span class="comment">/* unmask */</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data_len; i++)</span><br><span class="line">                        data[i + <span class="number">6</span>] ^= data[<span class="number">2</span> + i % <span class="number">4</span>];</span><br><span class="line">                    <span class="comment">/* user callback */</span></span><br><span class="line">                    websocket_cb(pcb, &amp;data[<span class="number">6</span>], data_len, opcode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x08</span>: <span class="comment">// close</span></span><br><span class="line">                <span class="keyword">return</span> ERR_CLSD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERR_VAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When server sends data to the client it is always unmasked. Our implementation won’t support packets larger than 125 bytes for simplicity.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">websocket_write</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">uint16_t</span> len, <span class="keyword">uint8_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">125</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[len + <span class="number">2</span>];</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0x80</span> | mode;</span><br><span class="line">    buf[<span class="number">1</span>] = len;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buf[<span class="number">2</span>], data, len);</span><br><span class="line">    len += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    tcp_write(pcb, buf, len, TCP_WRITE_FLAG_COPY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Closing-connection"><a href="#Closing-connection" class="headerlink" title="Closing connection"></a>Closing connection</h3><p>Simply closing a TCP connection is an option, but it’s considered to be an <em>unclean shutdown</em>. When one side wants to close a websocket, it sends a packet which contains   a reason for closing the connection. The other side then echoes this packet back and the connection is considered closed afterwards. Our implementation shall always close the connection with status code <code>1000</code> (normal closure).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> err_t <span class="title">websocket_close</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> buf[] = &#123;<span class="number">0x88</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0xe8</span>&#125;;</span><br><span class="line">    <span class="keyword">u16_t</span> len = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> tcp_write(pcb, buf, len, TCP_WRITE_FLAG_COPY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>I created a small project to demonstrate basic functionality. In this demo two sockets are used: one for polling by the client, and second one for streaming data from server.</p><img src="/blog/esp-httpd/websocket_demo.png" alt="WebSockets demo" title="WebSockets demo"><p>Code is available on <a href="https://github.com/lujji/esp-httpd">github</a>.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;This article will cover implementing a basic HTTP server on top of LwIP for ESP8266 and dive into the implementation of WebSockets.&lt;/p&gt;</summary>
    
    
    
    
    <category term="esp8266" scheme="http://lujji.github.io/blog/tags/esp8266/"/>
    
    <category term="freertos" scheme="http://lujji.github.io/blog/tags/freertos/"/>
    
    <category term="web" scheme="http://lujji.github.io/blog/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Reverse-engineering ST-Link firmware - Part 2</title>
    <link href="http://lujji.github.io/blog/reverse-engineering-stlink-firmware-part2/"/>
    <id>http://lujji.github.io/blog/reverse-engineering-stlink-firmware-part2/</id>
    <published>2016-10-16T21:00:00.000Z</published>
    <updated>2017-03-18T21:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the second part of ST-Link reverse-engineering, where I cover dumping the firmware, extracting and reverse-engineering the bootloader, and finally, patching the bootloader in order to disable Level 1 protection.</p><span id="more"></span><hr><h2 id="Dumping-the-bootloader"><a href="#Dumping-the-bootloader" class="headerlink" title="Dumping the bootloader"></a>Dumping the bootloader</h2><p>Dumping the firmware was the easiest part. Once the bootloader passes control to our code, we initialize clocks and UART. After that we send two marker bytes to indicate beginning of the firmware and then simply read all the flash memory starting from the address 0x08000000 and send it over UART one byte at a time. Since I was too lazy to implement any flow control, I opted for modest 9600 baud and added a small delay after each byte transfer just to make sure that I don’t hit a buffer overrun on my UART-USB converter. TX pin on UART2 is PA2 (there are solder-bridges for RX and TX on Discovery boards).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clock_setup();</span><br><span class="line">    usart_setup();</span><br><span class="line">    gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,</span><br><span class="line">            GPIO_CNF_OUTPUT_PUSHPULL, LED_PIN);</span><br><span class="line">    gpio_clear(GPIOA, LED_PIN);</span><br><span class="line"></span><br><span class="line">    usart_send_blocking(USART2, <span class="number">0xAB</span>);</span><br><span class="line">    usart_send_blocking(USART2, <span class="number">0xCD</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> addr = <span class="number">0x08000000</span>; addr &lt;= <span class="number">0x08010000</span>; addr++) &#123;</span><br><span class="line">        usart_send_blocking(USART2, *((<span class="keyword">uint16_t</span> *) addr));</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* loop forever */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After I accidentally triggered mass-erase on my Nucleo board, I had only one board with ST-Link v2-1 left. I didn’t want to risk, so I tried dumping a Chinese ST-Link v2 clone first. Once the update process finished, the programmer immediately started to spit out it’s own flash contents over the serial interface.</p><img src="/blog/reverse-engineering-stlink-firmware-part2/stlink_dump.png" alt="note: screenshot shows dumping of ST-Link v2-1" title="note: screenshot shows dumping of ST-Link v2-1"><p>As I mentioned before, visualizing raw binary data is a very useful trick during analysis. Let’s see what the dump looks like.</p><img src="/blog/reverse-engineering-stlink-firmware-part2/dump_visualization.png" alt="Firmware dump visualization" title="Firmware dump visualization"><p>We clearly see the separation between the bootloader and user code. Most importantly, there is a small chunk of data near the end of the bootloader section (later I discovered these bytes are written by the bootloader at the end of the update process to indicate a valid firmware). We can also see that first two pages of memory in the user code section were erased and now contain our dumper code.</p><p>As I mentioned in Part 1, my attempt to access the microcontroller through a debugger resulted in flash mass-erase. According to the reference manual, it implies that Level 1 protection is activated: <em>“Level 1 protection allows to recover a programmed part by erasing the entire Flash content. This is done by re-programming the RDP option byte from Level 1 to Level 0.”</em> The <a href="http://www.st.com/content/ccc/resource/technical/document/programming_manual/10/98/e8/d4/2b/51/4b/f5/CD00283419.pdf/files/CD00283419.pdf/jcr:content/translations/en.CD00283419.pdf">programming manual</a> tells us where the option bytes are located.</p><img src="/blog/reverse-engineering-stlink-firmware-part2/option_bytes.png" alt="""" title=""""><p>Before we move on to reverse-engineering the binary, let’s extract the bootloader section first, excluding the version bytes near the end:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> stlink_v2_dump.bin | <span class="built_in">head</span> -c 15360 &gt; ST-Link_bootloader.bin</span><br></pre></td></tr></table></figure><p>At this point, flashing bootloader onto an empty microcontroller will make the update utility think a blank ST-Link is connected. It will let you choose which firmware to flash, however the results will not be any different from what we achieved before by tricking the updater into flashing a different firmware.</p><h2 id="Reverse-engineering"><a href="#Reverse-engineering" class="headerlink" title="Reverse-engineering"></a>Reverse-engineering</h2><p>There are many disassemblers available for ARM out there. One of them even works. Unfortunately, IDA demo version does not support binary files. I tried using radare2, but after a while decided that I don’t have a spare lifetime to learn how to use all of it’s hot-keys and commands.</p><p>Eventually, I came across Hopper, which is a cross-platform disassembler. Demo version is limited to 30min sessions and does not allow saving projects or exporting files. That seemed good enough for me, so I gave it a try.</p><p>First things first, I searched for <code>0x1FFFF800</code> and sure enough - this constant was present.</p><img src="/blog/reverse-engineering-stlink-firmware-part2/hopper.png" alt="Hopper" title="Hopper"><p>It is referenced only once (hitting <code>X</code> lists all the references). If we follow the reference, we end up in a subroutine that presumably sets up the option bytes. Hopper can also generate pseudo-code. It’s not that great with loops and conditionals, but comes in handy when analyzing arithmetic operations.</p><img src="/blog/reverse-engineering-stlink-firmware-part2/set_option_bytes.png" alt="Pseudo-code" title="Pseudo-code"><p>This function is called only once, and if we follow the reference we end up in a section with quite a few function calls. Control flow graph shows that we identified main program loop at 0x2198. I tried visiting all the functions and guessing what they do.</p><img src="/blog/reverse-engineering-stlink-firmware-part2/main_loop.png" alt="Main loop" title="Main loop"><h2 id="Disabling-protection"><a href="#Disabling-protection" class="headerlink" title="Disabling protection"></a>Disabling protection</h2><p>We know that the function call to <code>option_bytes_config</code> is located at 0x21B2 in the binary dump. Let’s try to ‘nop’ it and see what we get. NOP is a pseudo-instruction on ARM cores, so we have to use something like ‘mov r8,r8’ to skip a cycle.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;mov r8, r8&quot;</span> | arm-none-eabi-as -mthumb -march=armv7 &amp;&amp; arm-none-eabi-objdump -d a.out</span><br><span class="line">...</span><br><span class="line">   0:   46c0            nop                     ; (mov r8, r8)</span><br></pre></td></tr></table></figure><p>Branch instruction occupies 4 bytes, which means we have to patch <code>C0 46 C0 46</code> to ‘nop’ the function call.</p><p>Next we flash the patched bootloader and use the updater utility to upload ST-Link firmware. Now let’s try dumping the firmware with openocd to see if protection is still enabled.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openocd -f interface/stlink-v2.cfg -c <span class="string">&#x27;transport select hla_swd&#x27;</span> \</span><br><span class="line">          -f target/stm32f1x.cfg -c <span class="string">&#x27;adapter_khz 4000&#x27;</span> -c init -c <span class="string">&#x27;reset halt&#x27;</span> \</span><br><span class="line">          -c <span class="string">&#x27;dump_image dump.bin 0x08000000 0x10000&#x27;</span> -c shutdown</span><br></pre></td></tr></table></figure><p>And this is what we get:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">stm32f1x.cpu: target state: halted</span><br><span class="line">target halted due to debug-request, current mode: Thread</span><br><span class="line">xPSR: 0x01000000 pc: 0x08002764 msp: 0x20000800</span><br><span class="line">dumped 65536 bytes in 0.427944s (149.552 KiB/s)</span><br></pre></td></tr></table></figure><p>Success!</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>After I dumped the firmware from the ST-Link v2 clone I successfully repeated the same procedure for an ST-Link v2-1. I used the same approach for removing protection, although the main program loop was a bit trickier to find. Being able to use a debugger makes it significantly easier to study the functionality of the bootloader and main firmware.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;This is the second part of ST-Link reverse-engineering, where I cover dumping the firmware, extracting and reverse-engineering the bootloader, and finally, patching the bootloader in order to disable Level 1 protection.&lt;/p&gt;</summary>
    
    
    
    
    <category term="st-link" scheme="http://lujji.github.io/blog/tags/st-link/"/>
    
    <category term="reverse-engineering" scheme="http://lujji.github.io/blog/tags/reverse-engineering/"/>
    
    <category term="stm32" scheme="http://lujji.github.io/blog/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>Reverse-engineering ST-Link firmware</title>
    <link href="http://lujji.github.io/blog/reverse-engineering-stlink-firmware/"/>
    <id>http://lujji.github.io/blog/reverse-engineering-stlink-firmware/</id>
    <published>2016-10-12T22:11:48.000Z</published>
    <updated>2017-03-18T21:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the first part of ST-Link reverse-engineering, where I cover analyzing and decompiling the updater utility, decrypting and encrypting firmware binaries and running custom code on ST-Link v2&#x2F;2-1 programmer.</p><span id="more"></span><hr><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>ST-Link 2 is a neat programmer. It can program, debug and even supports SWO Trace. The more I use it, the more I seem to forget about this <a href="abomination.jpg">abomination</a>. Recently, I came across a Nucleo board with an ST-Link v2-1, which in addition to all the regular features acts as a virtual COM port (VCP) and supports drag-n-drop upload. Sweet! Although I wasn’t very excited about the drag-n-drop thing, having UART for debugging on the same board comes in real handy. After studying the schematics I realized that the programmer is pretty much identical to a regular ST-Link v2 in terms of hardware. The only big difference is that v2-1 uses an MCU with 128k of flash versus 64k on v2 programmer. That made me think if there are any ways of getting UART on a ‘regular’ ST-Link. And so it began..</p><h2 id="Research"><a href="#Research" class="headerlink" title="Research"></a>Research</h2><p>EEVBlog forum user <code>eliocor</code> was kind enough to help and did a lot of research on the topic. He pointed me towards <a href="https://my.st.com/public/STe2ecommunities/mcu/Lists/cortex_mx_stm32/Flat.aspx?RootFolder=/public/STe2ecommunities/mcu/Lists/cortex_mx_stm32/Difference%20between%20ST-LINKV2-1%20and%20ST-LINKV2&FolderCTID=0x01200200770978C69A1141439FE559EB459D7580009C4E14902C3CDE46A77F0FFD06506F5B&currentviews=194">this</a> discussion on the ST forums. According to the ST employee, there are 4 versions of ST-Link 2: ST-Link&#x2F;v2, ST-Link&#x2F;v2-A, ST-Link&#x2F;v2-B and ST-Link&#x2F;v2-1. Presumably, A, B and 2-1 versions all have UART support and a different bootloader. ST-Link&#x2F;v2-1 also uses a larger MCU. Looking at windows drivers reveals a number of different PID combinations.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VID_0483&amp;PID_3748</span><br><span class="line">VID_0483&amp;PID_374A&amp;MI_00</span><br><span class="line">VID_0483&amp;PID_374B&amp;MI_00</span><br><span class="line">VID_0483&amp;PID_374A&amp;MI_01</span><br></pre></td></tr></table></figure><p>Initially, I tried connecting to the MCU with J-Link and see if we get anything useful. I launched J-Link Commander, typed ‘connect’ and was very surprised.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Active read protected STM32 device detected. This could cause problems during flash download.</span><br><span class="line">Device will be unsecured now.</span><br><span class="line">Note: Unsecuring will trigger a mass erase of the internal flash.</span><br></pre></td></tr></table></figure><p>MCU committed suicide. Flash was completely erased and I lost my ST-Link. Apparently, J-Link linux utility was ‘kind’ enough to remove option bytes without even asking the user.</p><p>Despite the fact that I lost my programmer, I still learned some useful information. Being able to unsecure the chip by erasing the flash contents suggests that Level 1 protection is active (more on that in Part 2).</p><h2 id="Analyzing-the-updater"><a href="#Analyzing-the-updater" class="headerlink" title="Analyzing the updater"></a>Analyzing the updater</h2><p>There is an article by Taylor Killian written in 2013, which covers extracting ST-Link firmware from the updater executable. At first I tried following the author’s approach and disassembling the windows executable. I searched for string references and soon found a part of code that decides which firmware to flash based on the ID of the programmer. It was implemented as a switch statement and the disassembly looked like a simple jump table. I fiddled around with various conditional jumps and was able to ‘help’ the program flash a different firmware into the programmer. After a few attempts I detached st-link from the virtual box and dmesg greeted me with the following:</p><img src="/blog/reverse-engineering-stlink-firmware/dmesg.png" alt="""" title=""""><p>Hah, piece of cake! I tried opening &#x2F;dev&#x2F;ttyACM2 - no errors. Then I connected a dev-board and tried flashing it with my upgraded st-link. It didn’t work. The official flash utility failed with ‘ST-Link USB error’ and openocd refused to see the programmer at all. Moreover, when I unplugged and reattached st-link, CDC interface was gone. For some reason st-link refused to exit DFU mode.</p><p>I played around with windows update utility but quickly got bored. Luckily, ST were kind enough to have a cross-platform updater written in java, so that we no longer have to fire up a virtual machine just to update the firmware.</p><p>Extracting STLinkUpgrade.jar reveals some interesting binaries. I tried to match them with corresponding labels from the updater:</p><ul><li><strong>f1_x.bin</strong>: ST-Link v1 firmwares. Not interested.</li><li><strong>f2_1.bin</strong>: “STM32 only”. Appears to be for Discovery boards.</li><li><strong>f2_2.bin</strong>: “STM8 only”. Also not interested.</li><li><strong>f2_3.bin</strong>: “STM32+STM8”. Standalone programmer, also used in Chinese clones.</li><li><strong>f2_4.bin</strong>: “STM32+MSD+VCP”. This one is for ST-Link v2-1 found on Nucleo boards.</li><li><strong>f2_5.bin</strong>: “STM32+Audio”. No idea.</li></ul><p>So the firmware with UART support is obviously f2_4, but there is a slight problem: ST-Link v2-1 on a Nucleo board features an STM32F103CBT6 microcontroller with 128k of flash, so it’s unlikely that we’ll ever manage to squeeze it into an F103C8. The firmware I’m most interested in is f2_5 (“STM32+Audio”) - I have no idea what “Audio” means, but we know that there are at least two versions of ST-Link with UART capability so, presumably, this firmware is for one of them.</p><p>The first obvious step was to rename these files inside the .jar archive and make the updater flash the firmware that we want. Unfortunately, the results were the same as with patching the windows executable.</p><p>The next step was to figure out what format these files have. When working with unknown data, it’s always a good idea to have a visual representation of some sort. Judging by the uniform distribution of data we can suspect some encryption or archiving involved.</p><img src="/blog/reverse-engineering-stlink-firmware/histogram.png" alt="Histogram of firmware data" title="Histogram of firmware data"><p>Now, it’s no secret that these binaries are encrypted with AES-128 and the key is stored inside the executable in plain ASCII, which was covered in the article I mentioned earlier. However, since I was planning to use the application itself to perform encryption&#x2F;decryption, this information was of little use to me. So without any further investigation I went on to decompiling the updater utility.</p><p>I used <a href="https://bitbucket.org/mstrobel/procyon/downloads">procyon decompiler</a>, reconstructed function calls and after a while was able to decrypt the firmware binary. Encryption key was <del>“worst HAL libraries”</del> “best performance”. Finally, I’ve hacked everything into a command-line utility, which is able to encrypt and decrypt binary images (code is available on <a href="https://github.com/lujji/st-decrypt">github</a>).</p><p>Let’s take a look at the decrypted file and search for known Unicode strings.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x00008ee0: 80 14 00 20 04 03 09 04 26 03 53 00 54 00 4d 00  ... ....&amp;.S.T.M.</span><br><span class="line">0x00008ef0: 69 00 63 00 72 00 6f 00 65 00 6c 00 65 00 63 00  i.c.r.o.e.l.e.c.</span><br><span class="line">0x00008f00: 74 00 72 00 6f 00 6e 00 69 00 63 00 73 00 00 00  t.r.o.n.i.c.s...</span><br><span class="line">0x00008f10: 1a 03 53 00 54 00 4d 00 33 00 32 00 20 00 53 00  ..S.T.M.3.2. .S.</span><br><span class="line">0x00008f20: 54 00 4c 00 69 00 6e 00 6b 00 00 00 1c 03 53 00  T.L.i.n.k.....S.</span><br><span class="line">0x00008f30: 54 00 2d 00 4c 00 69 00 6e 00 6b 00 20 00 44 00  T.-.L.i.n.k. .D.</span><br><span class="line">0x00008f40: 65 00 62 00 75 00 67 00 2d e9 f8 4f 00 24 fe f7  e.b.u.g.-..O.$..</span><br><span class="line">0x00008f50: 3d fa 82 46 00 22 4f f4 fa 61 04 20 fb f7 ee fc  =..F.&quot;O..a. ....</span><br></pre></td></tr></table></figure><p>Looks promissing, right? ;)</p><p>The next step was to change something in the decrypted firmware, encrypt it and send back to the device. It worked flawlessly. As a sanity check, I tried various combinations, including flashing a firmware consisting entirely of 0xFF bytes, just to make sure that the firmware is indeed accepted and written to the device.</p><p>At this point I was not interested in analyzing the firmware any further. I realized that the bootloader plays an important role, and I won’t be able to proceed without obtaining it.</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world"></a>Hello, world</h2><p>Knowing how to encrypt the firmware, I could flash anything I want. However, I had no idea how the bootloader decides whether or not the firmware is OK before it passes control to it. Therefore, I needed to test if the code would actually get executed on the device.</p><p>I decided to write a ‘Hello world’ program that would blink an LED on PA5 (SWCLK on the SWD connector). The first thing to do was to alter the linker script and offset the ROM section by the size of the bootloader section.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    rom (rx) : ORIGIN = 0x08004000, LENGTH = 64K - 0x4000</span><br><span class="line">    ram (rwx) : ORIGIN = 0x20000000, LENGTH = 20K</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The code is rather self-explanatory.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rcc_clock_setup_in_hse_8mhz_out_72mhz();</span><br><span class="line">    rcc_periph_clock_enable(RCC_GPIOA);</span><br><span class="line">    gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,</span><br><span class="line">        GPIO_CNF_OUTPUT_PUSHPULL, GPIO5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        gpio_toggle(GPIOA, GPIO5);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After compiling the binary I used my utility to encrypt the binary.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar st_decrypt.jar -k <span class="string">&quot;best performance&quot;</span> -i main.bin -o f2_3.bin --encrypt</span><br></pre></td></tr></table></figure><p>Next, we replace the original <code>f2_3.bin</code> with our own, compress the jar archive and update the firmware on the st-link. For this test I used my F4 Discovery board. The update process finishes with an error saying that it can’t exit DFU mode. Let’s take a look at the board now.</p><img src="/blog/reverse-engineering-stlink-firmware/blinking_led.jpg" alt="Current limiting? Never heard of." title="Current limiting? Never heard of."><p>It was the first time I was excited about a blinking LED on a development board ;) Once you unplug the power, st-link would start in DFU mode again (as it normally does). Each st-link related command like writing to flash or reading target voltage would first ask the st-link to exit DFU mode and start executing main firmware code.</p><p>Now I have a way of executing my own code on the programmer. The next obvious step is to retrieve the bootloader, which I’ll cover in Part 2.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;This is the first part of ST-Link reverse-engineering, where I cover analyzing and decompiling the updater utility, decrypting and encrypting firmware binaries and running custom code on ST-Link v2&amp;#x2F;2-1 programmer.&lt;/p&gt;</summary>
    
    
    
    
    <category term="st-link" scheme="http://lujji.github.io/blog/tags/st-link/"/>
    
    <category term="reverse-engineering" scheme="http://lujji.github.io/blog/tags/reverse-engineering/"/>
    
    <category term="stm32" scheme="http://lujji.github.io/blog/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>Adding Trace support to ST-Link clones</title>
    <link href="http://lujji.github.io/blog/stlink-clone-trace/"/>
    <id>http://lujji.github.io/blog/stlink-clone-trace/</id>
    <published>2016-09-10T17:54:00.000Z</published>
    <updated>2023-01-28T23:19:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>When it comes to programming ST microcontrollers, I prefer to use Discovery boards (mainly because you can <a href="https://www.segger.com/jlink-st-link.html">turn them into J-Link</a>). However, I got tired of carrying around the whole dev-board just for the programmer, so I ordered a cheap st-link clone due to it’s small form-factor.</p><span id="more"></span><h2 id="The-clone"><a href="#The-clone" class="headerlink" title="The clone"></a>The clone</h2><img src="/blog/stlink-clone-trace/st-link.jpg" alt="ST-Link clone" title="ST-Link clone"><p>For less than 3$ you get a nice dongle in aluminium case and some wires. After taking a closer look I noticed that there is no <strong>SWO</strong> pin on the pinout. Perhaps SWIM pin would dual-function as SWO when working with STM32? Unfortunately this wasn’t the case. So what, does it mean I have to use another USB cable just for UART? No way, I’m not going back to the stone age, I want my Trace!</p><h2 id="Research"><a href="#Research" class="headerlink" title="Research"></a>Research</h2><p>Trace is a very neat feature. One of the common uses is redirecting <code>stdout</code> stream to stimulus port 0 in order to printf debugging information. All recent versions of ST-Link v2 support this feature, so the first thing I did was check if the dongle is running the original ST-Link firmware. I launched ST-LINK Utility and updated the firmware with no issues whatsoever. So now we know that the dongle is running the latest official firmware and supports trace functionality.</p><img src="/blog/stlink-clone-trace/schematic.png" alt="ST-Link schematic" title="ST-Link schematic"><p>I couldn’t find schematics for a stand-alone programmer so I assumed it would be identical to the one present on Discovery board. PA10 is used for SWO so the next step would be pretty straight-forward.</p><h2 id="Modding"><a href="#Modding" class="headerlink" title="Modding"></a>Modding</h2><img src="/blog/stlink-clone-trace/st-link-mod.jpg" alt="5V pin converted into SWO" title="5V pin converted into SWO"><p>I’ve cut the trace from 5V pin right after the via and soldered some bodge-wire to PA10 (pin 31). I also added a 22Ω resistor in case something goes horribly wrong. Initially I wanted to use SWIM pin since I don’t care about STM8 and it would only require desoldering one resistor without cutting any traces, but the 5V pin was easier to reach.</p><p>Time for some testing.</p><img src="/blog/stlink-clone-trace/trace-screenshot.png" alt="""" title=""""><p>SWO Trace works perfectly fine which makes the dongle much more useful.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;When it comes to programming ST microcontrollers, I prefer to use Discovery boards (mainly because you can &lt;a href=&quot;https://www.segger.com/jlink-st-link.html&quot;&gt;turn them into J-Link&lt;/a&gt;). However, I got tired of carrying around the whole dev-board just for the programmer, so I ordered a cheap st-link clone due to it’s small form-factor.&lt;/p&gt;</summary>
    
    
    
    
    <category term="st-link" scheme="http://lujji.github.io/blog/tags/st-link/"/>
    
    <category term="stm32" scheme="http://lujji.github.io/blog/tags/stm32/"/>
    
    <category term="trace" scheme="http://lujji.github.io/blog/tags/trace/"/>
    
    <category term="swo" scheme="http://lujji.github.io/blog/tags/swo/"/>
    
  </entry>
  
</feed>
